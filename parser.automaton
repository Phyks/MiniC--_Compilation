State 0:
fichier' -> . fichier [ # ]
-- On INCLUDE shift to state 1
-- On fichier shift to state 2
-- On boption(INCLUDE) shift to state 3
-- On VOID reduce production boption(INCLUDE) -> 
-- On TINT reduce production boption(INCLUDE) -> 
-- On TIDENT reduce production boption(INCLUDE) -> 
-- On EOF reduce production boption(INCLUDE) -> 
-- On CLASS reduce production boption(INCLUDE) -> 

State 1:
boption(INCLUDE) -> INCLUDE . [ VOID TINT TIDENT EOF CLASS ]
-- On VOID reduce production boption(INCLUDE) -> INCLUDE 
-- On TINT reduce production boption(INCLUDE) -> INCLUDE 
-- On TIDENT reduce production boption(INCLUDE) -> INCLUDE 
-- On EOF reduce production boption(INCLUDE) -> INCLUDE 
-- On CLASS reduce production boption(INCLUDE) -> INCLUDE 

State 2:
fichier' -> fichier . [ # ]
-- On # accept fichier

State 3:
fichier -> boption(INCLUDE) . list(decl) EOF [ # ]
-- On VOID shift to state 4
-- On TINT shift to state 5
-- On TIDENT shift to state 6
-- On CLASS shift to state 28
-- On type_rule shift to state 70
-- On proto shift to state 74
-- On list(decl) shift to state 187
-- On decl_vars shift to state 189
-- On decl_class shift to state 190
-- On decl shift to state 191
-- On EOF reduce production list(decl) -> 

State 4:
type_rule -> VOID . [ TIMES TIDENT IDENT ECOMM ]
-- On TIMES reduce production type_rule -> VOID 
-- On TIDENT reduce production type_rule -> VOID 
-- On IDENT reduce production type_rule -> VOID 
-- On ECOMM reduce production type_rule -> VOID 

State 5:
type_rule -> TINT . [ TIMES TIDENT IDENT ECOMM ]
-- On TIMES reduce production type_rule -> TINT 
-- On TIDENT reduce production type_rule -> TINT 
-- On IDENT reduce production type_rule -> TINT 
-- On ECOMM reduce production type_rule -> TINT 

State 6:
proto -> TIDENT . paren(separated_list(COMMA,argument)) [ SEMICOLON LBRACE ]
proto -> TIDENT . COLON COLON TIDENT paren(separated_list(COMMA,argument)) [ SEMICOLON LBRACE ]
type_rule -> TIDENT . [ TIMES TIDENT IDENT ECOMM ]
-- On LPAREN shift to state 7
-- On COLON shift to state 23
-- On paren(separated_list(COMMA,argument)) shift to state 27
-- On TIMES reduce production type_rule -> TIDENT 
-- On TIDENT reduce production type_rule -> TIDENT 
-- On IDENT reduce production type_rule -> TIDENT 
-- On ECOMM reduce production type_rule -> TIDENT 

State 7:
paren(separated_list(COMMA,argument)) -> LPAREN . loption(separated_nonempty_list(COMMA,argument)) RPAREN [ SEMICOLON LBRACE ]
-- On VOID shift to state 4
-- On TINT shift to state 5
-- On TIDENT shift to state 8
-- On type_rule shift to state 9
-- On separated_nonempty_list(COMMA,argument) shift to state 17
-- On loption(separated_nonempty_list(COMMA,argument)) shift to state 18
-- On argument shift to state 20
-- On RPAREN reduce production loption(separated_nonempty_list(COMMA,argument)) -> 

State 8:
type_rule -> TIDENT . [ TIMES IDENT ECOMM ]
-- On TIMES reduce production type_rule -> TIDENT 
-- On IDENT reduce production type_rule -> TIDENT 
-- On ECOMM reduce production type_rule -> TIDENT 

State 9:
argument -> type_rule . var [ RPAREN COMMA ]
-- On TIMES shift to state 10
-- On IDENT shift to state 11
-- On ECOMM shift to state 12
-- On var shift to state 16
-- On unary_times shift to state 14

State 10:
unary_times -> TIMES . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production unary_times -> TIMES 
-- On TIMES reduce production unary_times -> TIMES 
-- On TIDENT reduce production unary_times -> TIMES 
-- On THIS reduce production unary_times -> TIMES 
-- On PLUS reduce production unary_times -> TIMES 
-- On NULL reduce production unary_times -> TIMES 
-- On NOT reduce production unary_times -> TIMES 
-- On NEW reduce production unary_times -> TIMES 
-- On MINUS reduce production unary_times -> TIMES 
-- On LPAREN reduce production unary_times -> TIMES 
-- On INT reduce production unary_times -> TIMES 
-- On INCR reduce production unary_times -> TIMES 
-- On IDENT reduce production unary_times -> TIMES 
-- On FALSE reduce production unary_times -> TIMES 
-- On ECOMM reduce production unary_times -> TIMES 
-- On DECR reduce production unary_times -> TIMES 

State 11:
var -> IDENT . [ SEMICOLON RPAREN COMMA ASSIGN ]
-- On SEMICOLON reduce production var -> IDENT 
-- On RPAREN reduce production var -> IDENT 
-- On COMMA reduce production var -> IDENT 
-- On ASSIGN reduce production var -> IDENT 

State 12:
var -> ECOMM . var [ SEMICOLON RPAREN COMMA ASSIGN ]
-- On TIMES shift to state 10
-- On IDENT shift to state 11
-- On ECOMM shift to state 12
-- On var shift to state 13
-- On unary_times shift to state 14

State 13:
var -> ECOMM var . [ SEMICOLON RPAREN COMMA ASSIGN ]
-- On SEMICOLON reduce production var -> ECOMM var 
-- On RPAREN reduce production var -> ECOMM var 
-- On COMMA reduce production var -> ECOMM var 
-- On ASSIGN reduce production var -> ECOMM var 

State 14:
var -> unary_times . var [ SEMICOLON RPAREN COMMA ASSIGN ]
-- On TIMES shift to state 10
-- On IDENT shift to state 11
-- On ECOMM shift to state 12
-- On var shift to state 15
-- On unary_times shift to state 14

State 15:
var -> unary_times var . [ SEMICOLON RPAREN COMMA ASSIGN ]
-- On SEMICOLON reduce production var -> unary_times var 
-- On RPAREN reduce production var -> unary_times var 
-- On COMMA reduce production var -> unary_times var 
-- On ASSIGN reduce production var -> unary_times var 

State 16:
argument -> type_rule var . [ RPAREN COMMA ]
-- On RPAREN reduce production argument -> type_rule var 
-- On COMMA reduce production argument -> type_rule var 

State 17:
loption(separated_nonempty_list(COMMA,argument)) -> separated_nonempty_list(COMMA,argument) . [ RPAREN ]
-- On RPAREN reduce production loption(separated_nonempty_list(COMMA,argument)) -> separated_nonempty_list(COMMA,argument) 

State 18:
paren(separated_list(COMMA,argument)) -> LPAREN loption(separated_nonempty_list(COMMA,argument)) . RPAREN [ SEMICOLON LBRACE ]
-- On RPAREN shift to state 19

State 19:
paren(separated_list(COMMA,argument)) -> LPAREN loption(separated_nonempty_list(COMMA,argument)) RPAREN . [ SEMICOLON LBRACE ]
-- On SEMICOLON reduce production paren(separated_list(COMMA,argument)) -> LPAREN loption(separated_nonempty_list(COMMA,argument)) RPAREN 
-- On LBRACE reduce production paren(separated_list(COMMA,argument)) -> LPAREN loption(separated_nonempty_list(COMMA,argument)) RPAREN 

State 20:
separated_nonempty_list(COMMA,argument) -> argument . [ RPAREN ]
separated_nonempty_list(COMMA,argument) -> argument . COMMA separated_nonempty_list(COMMA,argument) [ RPAREN ]
-- On COMMA shift to state 21
-- On RPAREN reduce production separated_nonempty_list(COMMA,argument) -> argument 

State 21:
separated_nonempty_list(COMMA,argument) -> argument COMMA . separated_nonempty_list(COMMA,argument) [ RPAREN ]
-- On VOID shift to state 4
-- On TINT shift to state 5
-- On TIDENT shift to state 8
-- On type_rule shift to state 9
-- On separated_nonempty_list(COMMA,argument) shift to state 22
-- On argument shift to state 20

State 22:
separated_nonempty_list(COMMA,argument) -> argument COMMA separated_nonempty_list(COMMA,argument) . [ RPAREN ]
-- On RPAREN reduce production separated_nonempty_list(COMMA,argument) -> argument COMMA separated_nonempty_list(COMMA,argument) 

State 23:
proto -> TIDENT COLON . COLON TIDENT paren(separated_list(COMMA,argument)) [ SEMICOLON LBRACE ]
-- On COLON shift to state 24

State 24:
proto -> TIDENT COLON COLON . TIDENT paren(separated_list(COMMA,argument)) [ SEMICOLON LBRACE ]
-- On TIDENT shift to state 25

State 25:
proto -> TIDENT COLON COLON TIDENT . paren(separated_list(COMMA,argument)) [ SEMICOLON LBRACE ]
-- On LPAREN shift to state 7
-- On paren(separated_list(COMMA,argument)) shift to state 26

State 26:
proto -> TIDENT COLON COLON TIDENT paren(separated_list(COMMA,argument)) . [ SEMICOLON LBRACE ]
-- On SEMICOLON reduce production proto -> TIDENT COLON COLON TIDENT paren(separated_list(COMMA,argument)) 
-- On LBRACE reduce production proto -> TIDENT COLON COLON TIDENT paren(separated_list(COMMA,argument)) 

State 27:
proto -> TIDENT paren(separated_list(COMMA,argument)) . [ SEMICOLON LBRACE ]
-- On SEMICOLON reduce production proto -> TIDENT paren(separated_list(COMMA,argument)) 
-- On LBRACE reduce production proto -> TIDENT paren(separated_list(COMMA,argument)) 

State 28:
decl_class -> CLASS . IDENT option(supers) LBRACE PUBLIC COLON list(member) RBRACE SEMICOLON [ VOID TINT TIDENT EOF CLASS ]
-- On IDENT shift to state 29

State 29:
decl_class -> CLASS IDENT . option(supers) LBRACE PUBLIC COLON list(member) RBRACE SEMICOLON [ VOID TINT TIDENT EOF CLASS ]
-- On COLON shift to state 30
-- On supers shift to state 36
-- On option(supers) shift to state 37
-- On LBRACE reduce production option(supers) -> 

State 30:
supers -> COLON . separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) [ LBRACE ]
-- On PUBLIC shift to state 31
-- On separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) shift to state 35

State 31:
separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) -> PUBLIC . TIDENT [ LBRACE ]
separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) -> PUBLIC . TIDENT COMMA separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) [ LBRACE ]
-- On TIDENT shift to state 32

State 32:
separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) -> PUBLIC TIDENT . [ LBRACE ]
separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) -> PUBLIC TIDENT . COMMA separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) [ LBRACE ]
-- On COMMA shift to state 33
-- On LBRACE reduce production separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) -> PUBLIC TIDENT 

State 33:
separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) -> PUBLIC TIDENT COMMA . separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) [ LBRACE ]
-- On PUBLIC shift to state 31
-- On separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) shift to state 34

State 34:
separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) -> PUBLIC TIDENT COMMA separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) . [ LBRACE ]
-- On LBRACE reduce production separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) -> PUBLIC TIDENT COMMA separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) 

State 35:
supers -> COLON separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) . [ LBRACE ]
-- On LBRACE reduce production supers -> COLON separated_nonempty_list(COMMA,preceded(PUBLIC,TIDENT)) 

State 36:
option(supers) -> supers . [ LBRACE ]
-- On LBRACE reduce production option(supers) -> supers 

State 37:
decl_class -> CLASS IDENT option(supers) . LBRACE PUBLIC COLON list(member) RBRACE SEMICOLON [ VOID TINT TIDENT EOF CLASS ]
-- On LBRACE shift to state 38

State 38:
decl_class -> CLASS IDENT option(supers) LBRACE . PUBLIC COLON list(member) RBRACE SEMICOLON [ VOID TINT TIDENT EOF CLASS ]
-- On PUBLIC shift to state 39

State 39:
decl_class -> CLASS IDENT option(supers) LBRACE PUBLIC . COLON list(member) RBRACE SEMICOLON [ VOID TINT TIDENT EOF CLASS ]
-- On COLON shift to state 40

State 40:
decl_class -> CLASS IDENT option(supers) LBRACE PUBLIC COLON . list(member) RBRACE SEMICOLON [ VOID TINT TIDENT EOF CLASS ]
-- On VOID shift to state 4
-- On VIRTUAL shift to state 41
-- On TINT shift to state 5
-- On TIDENT shift to state 8
-- On type_rule shift to state 42
-- On member shift to state 48
-- On list(member) shift to state 67
-- On decl_vars shift to state 50
-- On boption(VIRTUAL) shift to state 51
-- On VOID reduce production boption(VIRTUAL) -> 
-- On TINT reduce production boption(VIRTUAL) -> 
-- On TIDENT reduce production boption(VIRTUAL) -> 
-- On RBRACE reduce production list(member) -> 
** Conflict on VOID TINT TIDENT

State 41:
boption(VIRTUAL) -> VIRTUAL . [ VOID TINT TIDENT ]
-- On VOID reduce production boption(VIRTUAL) -> VIRTUAL 
-- On TINT reduce production boption(VIRTUAL) -> VIRTUAL 
-- On TIDENT reduce production boption(VIRTUAL) -> VIRTUAL 

State 42:
decl_vars -> type_rule . separated_nonempty_list(COMMA,var) SEMICOLON [ VOID VIRTUAL TINT TIDENT RBRACE ]
-- On TIMES shift to state 10
-- On IDENT shift to state 11
-- On ECOMM shift to state 12
-- On var shift to state 43
-- On unary_times shift to state 14
-- On separated_nonempty_list(COMMA,var) shift to state 46

State 43:
separated_nonempty_list(COMMA,var) -> var . [ SEMICOLON ]
separated_nonempty_list(COMMA,var) -> var . COMMA separated_nonempty_list(COMMA,var) [ SEMICOLON ]
-- On COMMA shift to state 44
-- On SEMICOLON reduce production separated_nonempty_list(COMMA,var) -> var 

State 44:
separated_nonempty_list(COMMA,var) -> var COMMA . separated_nonempty_list(COMMA,var) [ SEMICOLON ]
-- On TIMES shift to state 10
-- On IDENT shift to state 11
-- On ECOMM shift to state 12
-- On var shift to state 43
-- On unary_times shift to state 14
-- On separated_nonempty_list(COMMA,var) shift to state 45

State 45:
separated_nonempty_list(COMMA,var) -> var COMMA separated_nonempty_list(COMMA,var) . [ SEMICOLON ]
-- On SEMICOLON reduce production separated_nonempty_list(COMMA,var) -> var COMMA separated_nonempty_list(COMMA,var) 

State 46:
decl_vars -> type_rule separated_nonempty_list(COMMA,var) . SEMICOLON [ VOID VIRTUAL TINT TIDENT RBRACE EOF CLASS ]
-- On SEMICOLON shift to state 47

State 47:
decl_vars -> type_rule separated_nonempty_list(COMMA,var) SEMICOLON . [ VOID VIRTUAL TINT TIDENT RBRACE EOF CLASS ]
-- On VOID reduce production decl_vars -> type_rule separated_nonempty_list(COMMA,var) SEMICOLON 
-- On VIRTUAL reduce production decl_vars -> type_rule separated_nonempty_list(COMMA,var) SEMICOLON 
-- On TINT reduce production decl_vars -> type_rule separated_nonempty_list(COMMA,var) SEMICOLON 
-- On TIDENT reduce production decl_vars -> type_rule separated_nonempty_list(COMMA,var) SEMICOLON 
-- On RBRACE reduce production decl_vars -> type_rule separated_nonempty_list(COMMA,var) SEMICOLON 
-- On EOF reduce production decl_vars -> type_rule separated_nonempty_list(COMMA,var) SEMICOLON 
-- On CLASS reduce production decl_vars -> type_rule separated_nonempty_list(COMMA,var) SEMICOLON 

State 48:
list(member) -> member . list(member) [ RBRACE ]
-- On VOID shift to state 4
-- On VIRTUAL shift to state 41
-- On TINT shift to state 5
-- On TIDENT shift to state 8
-- On type_rule shift to state 42
-- On member shift to state 48
-- On list(member) shift to state 49
-- On decl_vars shift to state 50
-- On boption(VIRTUAL) shift to state 51
-- On VOID reduce production boption(VIRTUAL) -> 
-- On TINT reduce production boption(VIRTUAL) -> 
-- On TIDENT reduce production boption(VIRTUAL) -> 
-- On RBRACE reduce production list(member) -> 
** Conflict on VOID TINT TIDENT

State 49:
list(member) -> member list(member) . [ RBRACE ]
-- On RBRACE reduce production list(member) -> member list(member) 

State 50:
member -> decl_vars . [ VOID VIRTUAL TINT TIDENT RBRACE ]
-- On VOID reduce production member -> decl_vars 
-- On VIRTUAL reduce production member -> decl_vars 
-- On TINT reduce production member -> decl_vars 
-- On TIDENT reduce production member -> decl_vars 
-- On RBRACE reduce production member -> decl_vars 

State 51:
member -> boption(VIRTUAL) . proto SEMICOLON [ VOID VIRTUAL TINT TIDENT RBRACE ]
-- On VOID shift to state 4
-- On TINT shift to state 5
-- On TIDENT shift to state 6
-- On type_rule shift to state 52
-- On proto shift to state 65

State 52:
proto -> type_rule . qvar paren(separated_list(COMMA,argument)) [ SEMICOLON ]
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On IDENT shift to state 57
-- On ECOMM shift to state 58
-- On unary_times shift to state 59
-- On qvar shift to state 63
-- On qident shift to state 61

State 53:
qident -> TIDENT . COLON COLON IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On COLON shift to state 54

State 54:
qident -> TIDENT COLON . COLON IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On COLON shift to state 55

State 55:
qident -> TIDENT COLON COLON . IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On IDENT shift to state 56

State 56:
qident -> TIDENT COLON COLON IDENT . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production qident -> TIDENT COLON COLON IDENT 
-- On SEMICOLON reduce production qident -> TIDENT COLON COLON IDENT 
-- On RPAREN reduce production qident -> TIDENT COLON COLON IDENT 
-- On PLUS reduce production qident -> TIDENT COLON COLON IDENT 
-- On OR reduce production qident -> TIDENT COLON COLON IDENT 
-- On NEQ reduce production qident -> TIDENT COLON COLON IDENT 
-- On MOD reduce production qident -> TIDENT COLON COLON IDENT 
-- On MINUS reduce production qident -> TIDENT COLON COLON IDENT 
-- On LT reduce production qident -> TIDENT COLON COLON IDENT 
-- On LPAREN reduce production qident -> TIDENT COLON COLON IDENT 
-- On LEQ reduce production qident -> TIDENT COLON COLON IDENT 
-- On INCR reduce production qident -> TIDENT COLON COLON IDENT 
-- On IN reduce production qident -> TIDENT COLON COLON IDENT 
-- On GT reduce production qident -> TIDENT COLON COLON IDENT 
-- On GEQ reduce production qident -> TIDENT COLON COLON IDENT 
-- On EQ reduce production qident -> TIDENT COLON COLON IDENT 
-- On DOT reduce production qident -> TIDENT COLON COLON IDENT 
-- On DIV reduce production qident -> TIDENT COLON COLON IDENT 
-- On DECR reduce production qident -> TIDENT COLON COLON IDENT 
-- On COMMA reduce production qident -> TIDENT COLON COLON IDENT 
-- On ASSIGN reduce production qident -> TIDENT COLON COLON IDENT 
-- On ARROW reduce production qident -> TIDENT COLON COLON IDENT 
-- On AND reduce production qident -> TIDENT COLON COLON IDENT 

State 57:
qident -> IDENT . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production qident -> IDENT 
-- On SEMICOLON reduce production qident -> IDENT 
-- On RPAREN reduce production qident -> IDENT 
-- On PLUS reduce production qident -> IDENT 
-- On OR reduce production qident -> IDENT 
-- On NEQ reduce production qident -> IDENT 
-- On MOD reduce production qident -> IDENT 
-- On MINUS reduce production qident -> IDENT 
-- On LT reduce production qident -> IDENT 
-- On LPAREN reduce production qident -> IDENT 
-- On LEQ reduce production qident -> IDENT 
-- On INCR reduce production qident -> IDENT 
-- On IN reduce production qident -> IDENT 
-- On GT reduce production qident -> IDENT 
-- On GEQ reduce production qident -> IDENT 
-- On EQ reduce production qident -> IDENT 
-- On DOT reduce production qident -> IDENT 
-- On DIV reduce production qident -> IDENT 
-- On DECR reduce production qident -> IDENT 
-- On COMMA reduce production qident -> IDENT 
-- On ASSIGN reduce production qident -> IDENT 
-- On ARROW reduce production qident -> IDENT 
-- On AND reduce production qident -> IDENT 

State 58:
qvar -> ECOMM . qvar [ LPAREN ]
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On IDENT shift to state 57
-- On ECOMM shift to state 58
-- On unary_times shift to state 59
-- On qvar shift to state 62
-- On qident shift to state 61

State 59:
qvar -> unary_times . qvar [ LPAREN ]
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On IDENT shift to state 57
-- On ECOMM shift to state 58
-- On unary_times shift to state 59
-- On qvar shift to state 60
-- On qident shift to state 61

State 60:
qvar -> unary_times qvar . [ LPAREN ]
-- On LPAREN reduce production qvar -> unary_times qvar 

State 61:
qvar -> qident . [ LPAREN ]
-- On LPAREN reduce production qvar -> qident 

State 62:
qvar -> ECOMM qvar . [ LPAREN ]
-- On LPAREN reduce production qvar -> ECOMM qvar 

State 63:
proto -> type_rule qvar . paren(separated_list(COMMA,argument)) [ SEMICOLON LBRACE ]
-- On LPAREN shift to state 7
-- On paren(separated_list(COMMA,argument)) shift to state 64

State 64:
proto -> type_rule qvar paren(separated_list(COMMA,argument)) . [ SEMICOLON LBRACE ]
-- On SEMICOLON reduce production proto -> type_rule qvar paren(separated_list(COMMA,argument)) 
-- On LBRACE reduce production proto -> type_rule qvar paren(separated_list(COMMA,argument)) 

State 65:
member -> boption(VIRTUAL) proto . SEMICOLON [ VOID VIRTUAL TINT TIDENT RBRACE ]
-- On SEMICOLON shift to state 66

State 66:
member -> boption(VIRTUAL) proto SEMICOLON . [ VOID VIRTUAL TINT TIDENT RBRACE ]
-- On VOID reduce production member -> boption(VIRTUAL) proto SEMICOLON 
-- On VIRTUAL reduce production member -> boption(VIRTUAL) proto SEMICOLON 
-- On TINT reduce production member -> boption(VIRTUAL) proto SEMICOLON 
-- On TIDENT reduce production member -> boption(VIRTUAL) proto SEMICOLON 
-- On RBRACE reduce production member -> boption(VIRTUAL) proto SEMICOLON 

State 67:
decl_class -> CLASS IDENT option(supers) LBRACE PUBLIC COLON list(member) . RBRACE SEMICOLON [ VOID TINT TIDENT EOF CLASS ]
-- On RBRACE shift to state 68

State 68:
decl_class -> CLASS IDENT option(supers) LBRACE PUBLIC COLON list(member) RBRACE . SEMICOLON [ VOID TINT TIDENT EOF CLASS ]
-- On SEMICOLON shift to state 69

State 69:
decl_class -> CLASS IDENT option(supers) LBRACE PUBLIC COLON list(member) RBRACE SEMICOLON . [ VOID TINT TIDENT EOF CLASS ]
-- On VOID reduce production decl_class -> CLASS IDENT option(supers) LBRACE PUBLIC COLON list(member) RBRACE SEMICOLON 
-- On TINT reduce production decl_class -> CLASS IDENT option(supers) LBRACE PUBLIC COLON list(member) RBRACE SEMICOLON 
-- On TIDENT reduce production decl_class -> CLASS IDENT option(supers) LBRACE PUBLIC COLON list(member) RBRACE SEMICOLON 
-- On EOF reduce production decl_class -> CLASS IDENT option(supers) LBRACE PUBLIC COLON list(member) RBRACE SEMICOLON 
-- On CLASS reduce production decl_class -> CLASS IDENT option(supers) LBRACE PUBLIC COLON list(member) RBRACE SEMICOLON 

State 70:
decl_vars -> type_rule . separated_nonempty_list(COMMA,var) SEMICOLON [ VOID TINT TIDENT EOF CLASS ]
proto -> type_rule . qvar paren(separated_list(COMMA,argument)) [ LBRACE ]
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On IDENT shift to state 71
-- On ECOMM shift to state 72
-- On var shift to state 43
-- On unary_times shift to state 73
-- On separated_nonempty_list(COMMA,var) shift to state 46
-- On qvar shift to state 63
-- On qident shift to state 61

State 71:
qident -> IDENT . [ LPAREN ]
var -> IDENT . [ SEMICOLON COMMA ]
-- On SEMICOLON reduce production var -> IDENT 
-- On LPAREN reduce production qident -> IDENT 
-- On COMMA reduce production var -> IDENT 

State 72:
qvar -> ECOMM . qvar [ LPAREN ]
var -> ECOMM . var [ SEMICOLON COMMA ]
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On IDENT shift to state 71
-- On ECOMM shift to state 72
-- On var shift to state 13
-- On unary_times shift to state 73
-- On qvar shift to state 62
-- On qident shift to state 61

State 73:
qvar -> unary_times . qvar [ LPAREN ]
var -> unary_times . var [ SEMICOLON COMMA ]
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On IDENT shift to state 71
-- On ECOMM shift to state 72
-- On var shift to state 15
-- On unary_times shift to state 73
-- On qvar shift to state 60
-- On qident shift to state 61

State 74:
decl -> proto . bloc [ VOID TINT TIDENT EOF CLASS ]
-- On LBRACE shift to state 75
-- On bloc shift to state 186

State 75:
bloc -> LBRACE . list(instruction) RBRACE [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE EOF ELSE ECOMM DECR COUT CLASS ]
-- On WHILE shift to state 76
-- On VOID shift to state 4
-- On TRUE shift to state 78
-- On TINT shift to state 5
-- On TIMES shift to state 10
-- On TIDENT shift to state 138
-- On THIS shift to state 79
-- On SEMICOLON shift to state 139
-- On RETURN shift to state 140
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On LBRACE shift to state 75
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IF shift to state 144
-- On IDENT shift to state 57
-- On FOR shift to state 146
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On COUT shift to state 154
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On type_rule shift to state 162
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On list(instruction) shift to state 182
-- On instruction shift to state 184
-- On expr shift to state 175
-- On bloc shift to state 177
-- On RBRACE reduce production list(instruction) -> 

State 76:
instruction -> WHILE . paren(expr) instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On LPAREN shift to state 77
-- On paren(expr) shift to state 137

State 77:
paren(expr) -> LPAREN . expr RPAREN [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RPAREN RETURN PLUS OR NULL NOT NEW NEQ MOD MINUS LT LPAREN LEQ LBRACE INT INCR IN IF IDENT GT GEQ FOR FALSE EQ ECOMM DOT DIV DECR COUT COMMA ASSIGN ARROW AND ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On expr shift to state 135

State 78:
expr -> TRUE . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production expr -> TRUE 
-- On SEMICOLON reduce production expr -> TRUE 
-- On RPAREN reduce production expr -> TRUE 
-- On PLUS reduce production expr -> TRUE 
-- On OR reduce production expr -> TRUE 
-- On NEQ reduce production expr -> TRUE 
-- On MOD reduce production expr -> TRUE 
-- On MINUS reduce production expr -> TRUE 
-- On LT reduce production expr -> TRUE 
-- On LPAREN reduce production expr -> TRUE 
-- On LEQ reduce production expr -> TRUE 
-- On INCR reduce production expr -> TRUE 
-- On IN reduce production expr -> TRUE 
-- On GT reduce production expr -> TRUE 
-- On GEQ reduce production expr -> TRUE 
-- On EQ reduce production expr -> TRUE 
-- On DOT reduce production expr -> TRUE 
-- On DIV reduce production expr -> TRUE 
-- On DECR reduce production expr -> TRUE 
-- On COMMA reduce production expr -> TRUE 
-- On ASSIGN reduce production expr -> TRUE 
-- On ARROW reduce production expr -> TRUE 
-- On AND reduce production expr -> TRUE 

State 79:
expr -> THIS . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production expr -> THIS 
-- On SEMICOLON reduce production expr -> THIS 
-- On RPAREN reduce production expr -> THIS 
-- On PLUS reduce production expr -> THIS 
-- On OR reduce production expr -> THIS 
-- On NEQ reduce production expr -> THIS 
-- On MOD reduce production expr -> THIS 
-- On MINUS reduce production expr -> THIS 
-- On LT reduce production expr -> THIS 
-- On LPAREN reduce production expr -> THIS 
-- On LEQ reduce production expr -> THIS 
-- On INCR reduce production expr -> THIS 
-- On IN reduce production expr -> THIS 
-- On GT reduce production expr -> THIS 
-- On GEQ reduce production expr -> THIS 
-- On EQ reduce production expr -> THIS 
-- On DOT reduce production expr -> THIS 
-- On DIV reduce production expr -> THIS 
-- On DECR reduce production expr -> THIS 
-- On COMMA reduce production expr -> THIS 
-- On ASSIGN reduce production expr -> THIS 
-- On ARROW reduce production expr -> THIS 
-- On AND reduce production expr -> THIS 

State 80:
unary_plus -> PLUS . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production unary_plus -> PLUS 
-- On TIMES reduce production unary_plus -> PLUS 
-- On TIDENT reduce production unary_plus -> PLUS 
-- On THIS reduce production unary_plus -> PLUS 
-- On PLUS reduce production unary_plus -> PLUS 
-- On NULL reduce production unary_plus -> PLUS 
-- On NOT reduce production unary_plus -> PLUS 
-- On NEW reduce production unary_plus -> PLUS 
-- On MINUS reduce production unary_plus -> PLUS 
-- On LPAREN reduce production unary_plus -> PLUS 
-- On INT reduce production unary_plus -> PLUS 
-- On INCR reduce production unary_plus -> PLUS 
-- On IDENT reduce production unary_plus -> PLUS 
-- On FALSE reduce production unary_plus -> PLUS 
-- On ECOMM reduce production unary_plus -> PLUS 
-- On DECR reduce production unary_plus -> PLUS 

State 81:
expr -> NULL . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production expr -> NULL 
-- On SEMICOLON reduce production expr -> NULL 
-- On RPAREN reduce production expr -> NULL 
-- On PLUS reduce production expr -> NULL 
-- On OR reduce production expr -> NULL 
-- On NEQ reduce production expr -> NULL 
-- On MOD reduce production expr -> NULL 
-- On MINUS reduce production expr -> NULL 
-- On LT reduce production expr -> NULL 
-- On LPAREN reduce production expr -> NULL 
-- On LEQ reduce production expr -> NULL 
-- On INCR reduce production expr -> NULL 
-- On IN reduce production expr -> NULL 
-- On GT reduce production expr -> NULL 
-- On GEQ reduce production expr -> NULL 
-- On EQ reduce production expr -> NULL 
-- On DOT reduce production expr -> NULL 
-- On DIV reduce production expr -> NULL 
-- On DECR reduce production expr -> NULL 
-- On COMMA reduce production expr -> NULL 
-- On ASSIGN reduce production expr -> NULL 
-- On ARROW reduce production expr -> NULL 
-- On AND reduce production expr -> NULL 

State 82:
expr -> NOT . expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On expr shift to state 134

State 83:
expr -> NEW . TIDENT paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIDENT shift to state 84

State 84:
expr -> NEW TIDENT . paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On LPAREN shift to state 85
-- On paren(separated_list(COMMA,expr)) shift to state 133

State 85:
paren(separated_list(COMMA,expr)) -> LPAREN . loption(separated_nonempty_list(COMMA,expr)) RPAREN [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On separated_nonempty_list(COMMA,expr) shift to state 127
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On loption(separated_nonempty_list(COMMA,expr)) shift to state 128
-- On expr shift to state 130
-- On RPAREN reduce production loption(separated_nonempty_list(COMMA,expr)) -> 

State 86:
unary_minus -> MINUS . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production unary_minus -> MINUS 
-- On TIMES reduce production unary_minus -> MINUS 
-- On TIDENT reduce production unary_minus -> MINUS 
-- On THIS reduce production unary_minus -> MINUS 
-- On PLUS reduce production unary_minus -> MINUS 
-- On NULL reduce production unary_minus -> MINUS 
-- On NOT reduce production unary_minus -> MINUS 
-- On NEW reduce production unary_minus -> MINUS 
-- On MINUS reduce production unary_minus -> MINUS 
-- On LPAREN reduce production unary_minus -> MINUS 
-- On INT reduce production unary_minus -> MINUS 
-- On INCR reduce production unary_minus -> MINUS 
-- On IDENT reduce production unary_minus -> MINUS 
-- On FALSE reduce production unary_minus -> MINUS 
-- On ECOMM reduce production unary_minus -> MINUS 
-- On DECR reduce production unary_minus -> MINUS 

State 87:
expr -> INT . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production expr -> INT 
-- On SEMICOLON reduce production expr -> INT 
-- On RPAREN reduce production expr -> INT 
-- On PLUS reduce production expr -> INT 
-- On OR reduce production expr -> INT 
-- On NEQ reduce production expr -> INT 
-- On MOD reduce production expr -> INT 
-- On MINUS reduce production expr -> INT 
-- On LT reduce production expr -> INT 
-- On LPAREN reduce production expr -> INT 
-- On LEQ reduce production expr -> INT 
-- On INCR reduce production expr -> INT 
-- On IN reduce production expr -> INT 
-- On GT reduce production expr -> INT 
-- On GEQ reduce production expr -> INT 
-- On EQ reduce production expr -> INT 
-- On DOT reduce production expr -> INT 
-- On DIV reduce production expr -> INT 
-- On DECR reduce production expr -> INT 
-- On COMMA reduce production expr -> INT 
-- On ASSIGN reduce production expr -> INT 
-- On ARROW reduce production expr -> INT 
-- On AND reduce production expr -> INT 

State 88:
expr -> INCR . expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On expr shift to state 126

State 89:
expr -> FALSE . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production expr -> FALSE 
-- On SEMICOLON reduce production expr -> FALSE 
-- On RPAREN reduce production expr -> FALSE 
-- On PLUS reduce production expr -> FALSE 
-- On OR reduce production expr -> FALSE 
-- On NEQ reduce production expr -> FALSE 
-- On MOD reduce production expr -> FALSE 
-- On MINUS reduce production expr -> FALSE 
-- On LT reduce production expr -> FALSE 
-- On LPAREN reduce production expr -> FALSE 
-- On LEQ reduce production expr -> FALSE 
-- On INCR reduce production expr -> FALSE 
-- On IN reduce production expr -> FALSE 
-- On GT reduce production expr -> FALSE 
-- On GEQ reduce production expr -> FALSE 
-- On EQ reduce production expr -> FALSE 
-- On DOT reduce production expr -> FALSE 
-- On DIV reduce production expr -> FALSE 
-- On DECR reduce production expr -> FALSE 
-- On COMMA reduce production expr -> FALSE 
-- On ASSIGN reduce production expr -> FALSE 
-- On ARROW reduce production expr -> FALSE 
-- On AND reduce production expr -> FALSE 

State 90:
expr -> ECOMM . expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On expr shift to state 125

State 91:
expr -> DECR . expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On expr shift to state 124

State 92:
expr -> unary_times . expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On expr shift to state 123

State 93:
expr -> unary_plus . expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On expr shift to state 122

State 94:
expr -> unary_minus . expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On expr shift to state 97

State 95:
expr -> qident . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production expr -> qident 
-- On SEMICOLON reduce production expr -> qident 
-- On RPAREN reduce production expr -> qident 
-- On PLUS reduce production expr -> qident 
-- On OR reduce production expr -> qident 
-- On NEQ reduce production expr -> qident 
-- On MOD reduce production expr -> qident 
-- On MINUS reduce production expr -> qident 
-- On LT reduce production expr -> qident 
-- On LPAREN reduce production expr -> qident 
-- On LEQ reduce production expr -> qident 
-- On INCR reduce production expr -> qident 
-- On IN reduce production expr -> qident 
-- On GT reduce production expr -> qident 
-- On GEQ reduce production expr -> qident 
-- On EQ reduce production expr -> qident 
-- On DOT reduce production expr -> qident 
-- On DIV reduce production expr -> qident 
-- On DECR reduce production expr -> qident 
-- On COMMA reduce production expr -> qident 
-- On ASSIGN reduce production expr -> qident 
-- On ARROW reduce production expr -> qident 
-- On AND reduce production expr -> qident 

State 96:
expr -> paren(expr) . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production expr -> paren(expr) 
-- On SEMICOLON reduce production expr -> paren(expr) 
-- On RPAREN reduce production expr -> paren(expr) 
-- On PLUS reduce production expr -> paren(expr) 
-- On OR reduce production expr -> paren(expr) 
-- On NEQ reduce production expr -> paren(expr) 
-- On MOD reduce production expr -> paren(expr) 
-- On MINUS reduce production expr -> paren(expr) 
-- On LT reduce production expr -> paren(expr) 
-- On LPAREN reduce production expr -> paren(expr) 
-- On LEQ reduce production expr -> paren(expr) 
-- On INCR reduce production expr -> paren(expr) 
-- On IN reduce production expr -> paren(expr) 
-- On GT reduce production expr -> paren(expr) 
-- On GEQ reduce production expr -> paren(expr) 
-- On EQ reduce production expr -> paren(expr) 
-- On DOT reduce production expr -> paren(expr) 
-- On DIV reduce production expr -> paren(expr) 
-- On DECR reduce production expr -> paren(expr) 
-- On COMMA reduce production expr -> paren(expr) 
-- On ASSIGN reduce production expr -> paren(expr) 
-- On ARROW reduce production expr -> paren(expr) 
-- On AND reduce production expr -> paren(expr) 

State 97:
expr -> expr . DOT IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ARROW IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ASSIGN expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . INCR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . DECR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> unary_minus expr . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . operateur expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES shift to state 98
-- On PLUS shift to state 99
-- On OR shift to state 100
-- On NEQ shift to state 101
-- On MOD shift to state 102
-- On MINUS shift to state 103
-- On LT shift to state 104
-- On LPAREN shift to state 85
-- On LEQ shift to state 105
-- On INCR shift to state 106
-- On GT shift to state 107
-- On GEQ shift to state 108
-- On EQ shift to state 109
-- On DOT shift to state 110
-- On DIV shift to state 112
-- On DECR shift to state 113
-- On ASSIGN shift to state 114
-- On ARROW shift to state 116
-- On AND shift to state 118
-- On paren(separated_list(COMMA,expr)) shift to state 119
-- On operateur shift to state 120
-- On TIMES reduce production expr -> unary_minus expr 
-- On SEMICOLON reduce production expr -> unary_minus expr 
-- On RPAREN reduce production expr -> unary_minus expr 
-- On PLUS reduce production expr -> unary_minus expr 
-- On OR reduce production expr -> unary_minus expr 
-- On NEQ reduce production expr -> unary_minus expr 
-- On MOD reduce production expr -> unary_minus expr 
-- On MINUS reduce production expr -> unary_minus expr 
-- On LT reduce production expr -> unary_minus expr 
-- On LPAREN reduce production expr -> unary_minus expr 
-- On LEQ reduce production expr -> unary_minus expr 
-- On INCR reduce production expr -> unary_minus expr 
-- On IN reduce production expr -> unary_minus expr 
-- On GT reduce production expr -> unary_minus expr 
-- On GEQ reduce production expr -> unary_minus expr 
-- On EQ reduce production expr -> unary_minus expr 
-- On DOT reduce production expr -> unary_minus expr 
-- On DIV reduce production expr -> unary_minus expr 
-- On DECR reduce production expr -> unary_minus expr 
-- On COMMA reduce production expr -> unary_minus expr 
-- On ASSIGN reduce production expr -> unary_minus expr 
-- On ARROW reduce production expr -> unary_minus expr 
-- On AND reduce production expr -> unary_minus expr 
** Conflict on TIMES PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND

State 98:
operateur -> TIMES . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production operateur -> TIMES 
-- On TIMES reduce production operateur -> TIMES 
-- On TIDENT reduce production operateur -> TIMES 
-- On THIS reduce production operateur -> TIMES 
-- On PLUS reduce production operateur -> TIMES 
-- On NULL reduce production operateur -> TIMES 
-- On NOT reduce production operateur -> TIMES 
-- On NEW reduce production operateur -> TIMES 
-- On MINUS reduce production operateur -> TIMES 
-- On LPAREN reduce production operateur -> TIMES 
-- On INT reduce production operateur -> TIMES 
-- On INCR reduce production operateur -> TIMES 
-- On IDENT reduce production operateur -> TIMES 
-- On FALSE reduce production operateur -> TIMES 
-- On ECOMM reduce production operateur -> TIMES 
-- On DECR reduce production operateur -> TIMES 

State 99:
operateur -> PLUS . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production operateur -> PLUS 
-- On TIMES reduce production operateur -> PLUS 
-- On TIDENT reduce production operateur -> PLUS 
-- On THIS reduce production operateur -> PLUS 
-- On PLUS reduce production operateur -> PLUS 
-- On NULL reduce production operateur -> PLUS 
-- On NOT reduce production operateur -> PLUS 
-- On NEW reduce production operateur -> PLUS 
-- On MINUS reduce production operateur -> PLUS 
-- On LPAREN reduce production operateur -> PLUS 
-- On INT reduce production operateur -> PLUS 
-- On INCR reduce production operateur -> PLUS 
-- On IDENT reduce production operateur -> PLUS 
-- On FALSE reduce production operateur -> PLUS 
-- On ECOMM reduce production operateur -> PLUS 
-- On DECR reduce production operateur -> PLUS 

State 100:
operateur -> OR . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production operateur -> OR 
-- On TIMES reduce production operateur -> OR 
-- On TIDENT reduce production operateur -> OR 
-- On THIS reduce production operateur -> OR 
-- On PLUS reduce production operateur -> OR 
-- On NULL reduce production operateur -> OR 
-- On NOT reduce production operateur -> OR 
-- On NEW reduce production operateur -> OR 
-- On MINUS reduce production operateur -> OR 
-- On LPAREN reduce production operateur -> OR 
-- On INT reduce production operateur -> OR 
-- On INCR reduce production operateur -> OR 
-- On IDENT reduce production operateur -> OR 
-- On FALSE reduce production operateur -> OR 
-- On ECOMM reduce production operateur -> OR 
-- On DECR reduce production operateur -> OR 

State 101:
operateur -> NEQ . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production operateur -> NEQ 
-- On TIMES reduce production operateur -> NEQ 
-- On TIDENT reduce production operateur -> NEQ 
-- On THIS reduce production operateur -> NEQ 
-- On PLUS reduce production operateur -> NEQ 
-- On NULL reduce production operateur -> NEQ 
-- On NOT reduce production operateur -> NEQ 
-- On NEW reduce production operateur -> NEQ 
-- On MINUS reduce production operateur -> NEQ 
-- On LPAREN reduce production operateur -> NEQ 
-- On INT reduce production operateur -> NEQ 
-- On INCR reduce production operateur -> NEQ 
-- On IDENT reduce production operateur -> NEQ 
-- On FALSE reduce production operateur -> NEQ 
-- On ECOMM reduce production operateur -> NEQ 
-- On DECR reduce production operateur -> NEQ 

State 102:
operateur -> MOD . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production operateur -> MOD 
-- On TIMES reduce production operateur -> MOD 
-- On TIDENT reduce production operateur -> MOD 
-- On THIS reduce production operateur -> MOD 
-- On PLUS reduce production operateur -> MOD 
-- On NULL reduce production operateur -> MOD 
-- On NOT reduce production operateur -> MOD 
-- On NEW reduce production operateur -> MOD 
-- On MINUS reduce production operateur -> MOD 
-- On LPAREN reduce production operateur -> MOD 
-- On INT reduce production operateur -> MOD 
-- On INCR reduce production operateur -> MOD 
-- On IDENT reduce production operateur -> MOD 
-- On FALSE reduce production operateur -> MOD 
-- On ECOMM reduce production operateur -> MOD 
-- On DECR reduce production operateur -> MOD 

State 103:
operateur -> MINUS . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production operateur -> MINUS 
-- On TIMES reduce production operateur -> MINUS 
-- On TIDENT reduce production operateur -> MINUS 
-- On THIS reduce production operateur -> MINUS 
-- On PLUS reduce production operateur -> MINUS 
-- On NULL reduce production operateur -> MINUS 
-- On NOT reduce production operateur -> MINUS 
-- On NEW reduce production operateur -> MINUS 
-- On MINUS reduce production operateur -> MINUS 
-- On LPAREN reduce production operateur -> MINUS 
-- On INT reduce production operateur -> MINUS 
-- On INCR reduce production operateur -> MINUS 
-- On IDENT reduce production operateur -> MINUS 
-- On FALSE reduce production operateur -> MINUS 
-- On ECOMM reduce production operateur -> MINUS 
-- On DECR reduce production operateur -> MINUS 

State 104:
operateur -> LT . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production operateur -> LT 
-- On TIMES reduce production operateur -> LT 
-- On TIDENT reduce production operateur -> LT 
-- On THIS reduce production operateur -> LT 
-- On PLUS reduce production operateur -> LT 
-- On NULL reduce production operateur -> LT 
-- On NOT reduce production operateur -> LT 
-- On NEW reduce production operateur -> LT 
-- On MINUS reduce production operateur -> LT 
-- On LPAREN reduce production operateur -> LT 
-- On INT reduce production operateur -> LT 
-- On INCR reduce production operateur -> LT 
-- On IDENT reduce production operateur -> LT 
-- On FALSE reduce production operateur -> LT 
-- On ECOMM reduce production operateur -> LT 
-- On DECR reduce production operateur -> LT 

State 105:
operateur -> LEQ . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production operateur -> LEQ 
-- On TIMES reduce production operateur -> LEQ 
-- On TIDENT reduce production operateur -> LEQ 
-- On THIS reduce production operateur -> LEQ 
-- On PLUS reduce production operateur -> LEQ 
-- On NULL reduce production operateur -> LEQ 
-- On NOT reduce production operateur -> LEQ 
-- On NEW reduce production operateur -> LEQ 
-- On MINUS reduce production operateur -> LEQ 
-- On LPAREN reduce production operateur -> LEQ 
-- On INT reduce production operateur -> LEQ 
-- On INCR reduce production operateur -> LEQ 
-- On IDENT reduce production operateur -> LEQ 
-- On FALSE reduce production operateur -> LEQ 
-- On ECOMM reduce production operateur -> LEQ 
-- On DECR reduce production operateur -> LEQ 

State 106:
expr -> expr INCR . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production expr -> expr INCR 
-- On SEMICOLON reduce production expr -> expr INCR 
-- On RPAREN reduce production expr -> expr INCR 
-- On PLUS reduce production expr -> expr INCR 
-- On OR reduce production expr -> expr INCR 
-- On NEQ reduce production expr -> expr INCR 
-- On MOD reduce production expr -> expr INCR 
-- On MINUS reduce production expr -> expr INCR 
-- On LT reduce production expr -> expr INCR 
-- On LPAREN reduce production expr -> expr INCR 
-- On LEQ reduce production expr -> expr INCR 
-- On INCR reduce production expr -> expr INCR 
-- On IN reduce production expr -> expr INCR 
-- On GT reduce production expr -> expr INCR 
-- On GEQ reduce production expr -> expr INCR 
-- On EQ reduce production expr -> expr INCR 
-- On DOT reduce production expr -> expr INCR 
-- On DIV reduce production expr -> expr INCR 
-- On DECR reduce production expr -> expr INCR 
-- On COMMA reduce production expr -> expr INCR 
-- On ASSIGN reduce production expr -> expr INCR 
-- On ARROW reduce production expr -> expr INCR 
-- On AND reduce production expr -> expr INCR 

State 107:
operateur -> GT . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production operateur -> GT 
-- On TIMES reduce production operateur -> GT 
-- On TIDENT reduce production operateur -> GT 
-- On THIS reduce production operateur -> GT 
-- On PLUS reduce production operateur -> GT 
-- On NULL reduce production operateur -> GT 
-- On NOT reduce production operateur -> GT 
-- On NEW reduce production operateur -> GT 
-- On MINUS reduce production operateur -> GT 
-- On LPAREN reduce production operateur -> GT 
-- On INT reduce production operateur -> GT 
-- On INCR reduce production operateur -> GT 
-- On IDENT reduce production operateur -> GT 
-- On FALSE reduce production operateur -> GT 
-- On ECOMM reduce production operateur -> GT 
-- On DECR reduce production operateur -> GT 

State 108:
operateur -> GEQ . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production operateur -> GEQ 
-- On TIMES reduce production operateur -> GEQ 
-- On TIDENT reduce production operateur -> GEQ 
-- On THIS reduce production operateur -> GEQ 
-- On PLUS reduce production operateur -> GEQ 
-- On NULL reduce production operateur -> GEQ 
-- On NOT reduce production operateur -> GEQ 
-- On NEW reduce production operateur -> GEQ 
-- On MINUS reduce production operateur -> GEQ 
-- On LPAREN reduce production operateur -> GEQ 
-- On INT reduce production operateur -> GEQ 
-- On INCR reduce production operateur -> GEQ 
-- On IDENT reduce production operateur -> GEQ 
-- On FALSE reduce production operateur -> GEQ 
-- On ECOMM reduce production operateur -> GEQ 
-- On DECR reduce production operateur -> GEQ 

State 109:
operateur -> EQ . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production operateur -> EQ 
-- On TIMES reduce production operateur -> EQ 
-- On TIDENT reduce production operateur -> EQ 
-- On THIS reduce production operateur -> EQ 
-- On PLUS reduce production operateur -> EQ 
-- On NULL reduce production operateur -> EQ 
-- On NOT reduce production operateur -> EQ 
-- On NEW reduce production operateur -> EQ 
-- On MINUS reduce production operateur -> EQ 
-- On LPAREN reduce production operateur -> EQ 
-- On INT reduce production operateur -> EQ 
-- On INCR reduce production operateur -> EQ 
-- On IDENT reduce production operateur -> EQ 
-- On FALSE reduce production operateur -> EQ 
-- On ECOMM reduce production operateur -> EQ 
-- On DECR reduce production operateur -> EQ 

State 110:
expr -> expr DOT . IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On IDENT shift to state 111

State 111:
expr -> expr DOT IDENT . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production expr -> expr DOT IDENT 
-- On SEMICOLON reduce production expr -> expr DOT IDENT 
-- On RPAREN reduce production expr -> expr DOT IDENT 
-- On PLUS reduce production expr -> expr DOT IDENT 
-- On OR reduce production expr -> expr DOT IDENT 
-- On NEQ reduce production expr -> expr DOT IDENT 
-- On MOD reduce production expr -> expr DOT IDENT 
-- On MINUS reduce production expr -> expr DOT IDENT 
-- On LT reduce production expr -> expr DOT IDENT 
-- On LPAREN reduce production expr -> expr DOT IDENT 
-- On LEQ reduce production expr -> expr DOT IDENT 
-- On INCR reduce production expr -> expr DOT IDENT 
-- On IN reduce production expr -> expr DOT IDENT 
-- On GT reduce production expr -> expr DOT IDENT 
-- On GEQ reduce production expr -> expr DOT IDENT 
-- On EQ reduce production expr -> expr DOT IDENT 
-- On DOT reduce production expr -> expr DOT IDENT 
-- On DIV reduce production expr -> expr DOT IDENT 
-- On DECR reduce production expr -> expr DOT IDENT 
-- On COMMA reduce production expr -> expr DOT IDENT 
-- On ASSIGN reduce production expr -> expr DOT IDENT 
-- On ARROW reduce production expr -> expr DOT IDENT 
-- On AND reduce production expr -> expr DOT IDENT 

State 112:
operateur -> DIV . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production operateur -> DIV 
-- On TIMES reduce production operateur -> DIV 
-- On TIDENT reduce production operateur -> DIV 
-- On THIS reduce production operateur -> DIV 
-- On PLUS reduce production operateur -> DIV 
-- On NULL reduce production operateur -> DIV 
-- On NOT reduce production operateur -> DIV 
-- On NEW reduce production operateur -> DIV 
-- On MINUS reduce production operateur -> DIV 
-- On LPAREN reduce production operateur -> DIV 
-- On INT reduce production operateur -> DIV 
-- On INCR reduce production operateur -> DIV 
-- On IDENT reduce production operateur -> DIV 
-- On FALSE reduce production operateur -> DIV 
-- On ECOMM reduce production operateur -> DIV 
-- On DECR reduce production operateur -> DIV 

State 113:
expr -> expr DECR . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production expr -> expr DECR 
-- On SEMICOLON reduce production expr -> expr DECR 
-- On RPAREN reduce production expr -> expr DECR 
-- On PLUS reduce production expr -> expr DECR 
-- On OR reduce production expr -> expr DECR 
-- On NEQ reduce production expr -> expr DECR 
-- On MOD reduce production expr -> expr DECR 
-- On MINUS reduce production expr -> expr DECR 
-- On LT reduce production expr -> expr DECR 
-- On LPAREN reduce production expr -> expr DECR 
-- On LEQ reduce production expr -> expr DECR 
-- On INCR reduce production expr -> expr DECR 
-- On IN reduce production expr -> expr DECR 
-- On GT reduce production expr -> expr DECR 
-- On GEQ reduce production expr -> expr DECR 
-- On EQ reduce production expr -> expr DECR 
-- On DOT reduce production expr -> expr DECR 
-- On DIV reduce production expr -> expr DECR 
-- On DECR reduce production expr -> expr DECR 
-- On COMMA reduce production expr -> expr DECR 
-- On ASSIGN reduce production expr -> expr DECR 
-- On ARROW reduce production expr -> expr DECR 
-- On AND reduce production expr -> expr DECR 

State 114:
expr -> expr ASSIGN . expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On expr shift to state 115

State 115:
expr -> expr . DOT IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ARROW IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ASSIGN expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr ASSIGN expr . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . INCR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . DECR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . operateur expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES shift to state 98
-- On PLUS shift to state 99
-- On OR shift to state 100
-- On NEQ shift to state 101
-- On MOD shift to state 102
-- On MINUS shift to state 103
-- On LT shift to state 104
-- On LPAREN shift to state 85
-- On LEQ shift to state 105
-- On INCR shift to state 106
-- On GT shift to state 107
-- On GEQ shift to state 108
-- On EQ shift to state 109
-- On DOT shift to state 110
-- On DIV shift to state 112
-- On DECR shift to state 113
-- On ASSIGN shift to state 114
-- On ARROW shift to state 116
-- On AND shift to state 118
-- On paren(separated_list(COMMA,expr)) shift to state 119
-- On operateur shift to state 120
-- On SEMICOLON reduce production expr -> expr ASSIGN expr 
-- On RPAREN reduce production expr -> expr ASSIGN expr 
-- On LPAREN reduce production expr -> expr ASSIGN expr 
-- On IN reduce production expr -> expr ASSIGN expr 
-- On COMMA reduce production expr -> expr ASSIGN expr 
** Conflict on LPAREN

State 116:
expr -> expr ARROW . IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On IDENT shift to state 117

State 117:
expr -> expr ARROW IDENT . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production expr -> expr ARROW IDENT 
-- On SEMICOLON reduce production expr -> expr ARROW IDENT 
-- On RPAREN reduce production expr -> expr ARROW IDENT 
-- On PLUS reduce production expr -> expr ARROW IDENT 
-- On OR reduce production expr -> expr ARROW IDENT 
-- On NEQ reduce production expr -> expr ARROW IDENT 
-- On MOD reduce production expr -> expr ARROW IDENT 
-- On MINUS reduce production expr -> expr ARROW IDENT 
-- On LT reduce production expr -> expr ARROW IDENT 
-- On LPAREN reduce production expr -> expr ARROW IDENT 
-- On LEQ reduce production expr -> expr ARROW IDENT 
-- On INCR reduce production expr -> expr ARROW IDENT 
-- On IN reduce production expr -> expr ARROW IDENT 
-- On GT reduce production expr -> expr ARROW IDENT 
-- On GEQ reduce production expr -> expr ARROW IDENT 
-- On EQ reduce production expr -> expr ARROW IDENT 
-- On DOT reduce production expr -> expr ARROW IDENT 
-- On DIV reduce production expr -> expr ARROW IDENT 
-- On DECR reduce production expr -> expr ARROW IDENT 
-- On COMMA reduce production expr -> expr ARROW IDENT 
-- On ASSIGN reduce production expr -> expr ARROW IDENT 
-- On ARROW reduce production expr -> expr ARROW IDENT 
-- On AND reduce production expr -> expr ARROW IDENT 

State 118:
operateur -> AND . [ TRUE TIMES TIDENT THIS PLUS NULL NOT NEW MINUS LPAREN INT INCR IDENT FALSE ECOMM DECR ]
-- On TRUE reduce production operateur -> AND 
-- On TIMES reduce production operateur -> AND 
-- On TIDENT reduce production operateur -> AND 
-- On THIS reduce production operateur -> AND 
-- On PLUS reduce production operateur -> AND 
-- On NULL reduce production operateur -> AND 
-- On NOT reduce production operateur -> AND 
-- On NEW reduce production operateur -> AND 
-- On MINUS reduce production operateur -> AND 
-- On LPAREN reduce production operateur -> AND 
-- On INT reduce production operateur -> AND 
-- On INCR reduce production operateur -> AND 
-- On IDENT reduce production operateur -> AND 
-- On FALSE reduce production operateur -> AND 
-- On ECOMM reduce production operateur -> AND 
-- On DECR reduce production operateur -> AND 

State 119:
expr -> expr paren(separated_list(COMMA,expr)) . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On SEMICOLON reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On RPAREN reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On PLUS reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On OR reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On NEQ reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On MOD reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On MINUS reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On LT reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On LPAREN reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On LEQ reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On INCR reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On IN reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On GT reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On GEQ reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On EQ reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On DOT reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On DIV reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On DECR reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On COMMA reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On ASSIGN reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On ARROW reduce production expr -> expr paren(separated_list(COMMA,expr)) 
-- On AND reduce production expr -> expr paren(separated_list(COMMA,expr)) 

State 120:
expr -> expr operateur . expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On expr shift to state 121

State 121:
expr -> expr . DOT IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ARROW IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ASSIGN expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . INCR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . DECR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . operateur expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr operateur expr . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES shift to state 98
-- On PLUS shift to state 99
-- On OR shift to state 100
-- On NEQ shift to state 101
-- On MOD shift to state 102
-- On MINUS shift to state 103
-- On LT shift to state 104
-- On LPAREN shift to state 85
-- On LEQ shift to state 105
-- On INCR shift to state 106
-- On GT shift to state 107
-- On GEQ shift to state 108
-- On EQ shift to state 109
-- On DOT shift to state 110
-- On DIV shift to state 112
-- On DECR shift to state 113
-- On ASSIGN shift to state 114
-- On ARROW shift to state 116
-- On AND shift to state 118
-- On paren(separated_list(COMMA,expr)) shift to state 119
-- On operateur shift to state 120
-- On TIMES reduce production expr -> expr operateur expr 
-- On SEMICOLON reduce production expr -> expr operateur expr 
-- On RPAREN reduce production expr -> expr operateur expr 
-- On PLUS reduce production expr -> expr operateur expr 
-- On OR reduce production expr -> expr operateur expr 
-- On NEQ reduce production expr -> expr operateur expr 
-- On MOD reduce production expr -> expr operateur expr 
-- On MINUS reduce production expr -> expr operateur expr 
-- On LT reduce production expr -> expr operateur expr 
-- On LPAREN reduce production expr -> expr operateur expr 
-- On LEQ reduce production expr -> expr operateur expr 
-- On INCR reduce production expr -> expr operateur expr 
-- On IN reduce production expr -> expr operateur expr 
-- On GT reduce production expr -> expr operateur expr 
-- On GEQ reduce production expr -> expr operateur expr 
-- On EQ reduce production expr -> expr operateur expr 
-- On DOT reduce production expr -> expr operateur expr 
-- On DIV reduce production expr -> expr operateur expr 
-- On DECR reduce production expr -> expr operateur expr 
-- On COMMA reduce production expr -> expr operateur expr 
-- On ASSIGN reduce production expr -> expr operateur expr 
-- On ARROW reduce production expr -> expr operateur expr 
-- On AND reduce production expr -> expr operateur expr 
** Conflict on TIMES PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND

State 122:
expr -> expr . DOT IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ARROW IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ASSIGN expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . INCR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . DECR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> unary_plus expr . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . operateur expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES shift to state 98
-- On PLUS shift to state 99
-- On OR shift to state 100
-- On NEQ shift to state 101
-- On MOD shift to state 102
-- On MINUS shift to state 103
-- On LT shift to state 104
-- On LPAREN shift to state 85
-- On LEQ shift to state 105
-- On INCR shift to state 106
-- On GT shift to state 107
-- On GEQ shift to state 108
-- On EQ shift to state 109
-- On DOT shift to state 110
-- On DIV shift to state 112
-- On DECR shift to state 113
-- On ASSIGN shift to state 114
-- On ARROW shift to state 116
-- On AND shift to state 118
-- On paren(separated_list(COMMA,expr)) shift to state 119
-- On operateur shift to state 120
-- On TIMES reduce production expr -> unary_plus expr 
-- On SEMICOLON reduce production expr -> unary_plus expr 
-- On RPAREN reduce production expr -> unary_plus expr 
-- On PLUS reduce production expr -> unary_plus expr 
-- On OR reduce production expr -> unary_plus expr 
-- On NEQ reduce production expr -> unary_plus expr 
-- On MOD reduce production expr -> unary_plus expr 
-- On MINUS reduce production expr -> unary_plus expr 
-- On LT reduce production expr -> unary_plus expr 
-- On LPAREN reduce production expr -> unary_plus expr 
-- On LEQ reduce production expr -> unary_plus expr 
-- On INCR reduce production expr -> unary_plus expr 
-- On IN reduce production expr -> unary_plus expr 
-- On GT reduce production expr -> unary_plus expr 
-- On GEQ reduce production expr -> unary_plus expr 
-- On EQ reduce production expr -> unary_plus expr 
-- On DOT reduce production expr -> unary_plus expr 
-- On DIV reduce production expr -> unary_plus expr 
-- On DECR reduce production expr -> unary_plus expr 
-- On COMMA reduce production expr -> unary_plus expr 
-- On ASSIGN reduce production expr -> unary_plus expr 
-- On ARROW reduce production expr -> unary_plus expr 
-- On AND reduce production expr -> unary_plus expr 
** Conflict on TIMES PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND

State 123:
expr -> unary_times expr . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . DOT IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ARROW IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ASSIGN expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . INCR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . DECR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . operateur expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES shift to state 98
-- On PLUS shift to state 99
-- On OR shift to state 100
-- On NEQ shift to state 101
-- On MOD shift to state 102
-- On MINUS shift to state 103
-- On LT shift to state 104
-- On LPAREN shift to state 85
-- On LEQ shift to state 105
-- On INCR shift to state 106
-- On GT shift to state 107
-- On GEQ shift to state 108
-- On EQ shift to state 109
-- On DOT shift to state 110
-- On DIV shift to state 112
-- On DECR shift to state 113
-- On ASSIGN shift to state 114
-- On ARROW shift to state 116
-- On AND shift to state 118
-- On paren(separated_list(COMMA,expr)) shift to state 119
-- On operateur shift to state 120
-- On TIMES reduce production expr -> unary_times expr 
-- On SEMICOLON reduce production expr -> unary_times expr 
-- On RPAREN reduce production expr -> unary_times expr 
-- On PLUS reduce production expr -> unary_times expr 
-- On OR reduce production expr -> unary_times expr 
-- On NEQ reduce production expr -> unary_times expr 
-- On MOD reduce production expr -> unary_times expr 
-- On MINUS reduce production expr -> unary_times expr 
-- On LT reduce production expr -> unary_times expr 
-- On LPAREN reduce production expr -> unary_times expr 
-- On LEQ reduce production expr -> unary_times expr 
-- On INCR reduce production expr -> unary_times expr 
-- On IN reduce production expr -> unary_times expr 
-- On GT reduce production expr -> unary_times expr 
-- On GEQ reduce production expr -> unary_times expr 
-- On EQ reduce production expr -> unary_times expr 
-- On DOT reduce production expr -> unary_times expr 
-- On DIV reduce production expr -> unary_times expr 
-- On DECR reduce production expr -> unary_times expr 
-- On COMMA reduce production expr -> unary_times expr 
-- On ASSIGN reduce production expr -> unary_times expr 
-- On ARROW reduce production expr -> unary_times expr 
-- On AND reduce production expr -> unary_times expr 
** Conflict on TIMES PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND

State 124:
expr -> expr . DOT IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ARROW IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ASSIGN expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> DECR expr . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . INCR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . DECR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . operateur expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On LPAREN shift to state 85
-- On INCR shift to state 106
-- On DOT shift to state 110
-- On DECR shift to state 113
-- On ARROW shift to state 116
-- On paren(separated_list(COMMA,expr)) shift to state 119
-- On operateur shift to state 120
-- On TIMES reduce production expr -> DECR expr 
-- On SEMICOLON reduce production expr -> DECR expr 
-- On RPAREN reduce production expr -> DECR expr 
-- On PLUS reduce production expr -> DECR expr 
-- On OR reduce production expr -> DECR expr 
-- On NEQ reduce production expr -> DECR expr 
-- On MOD reduce production expr -> DECR expr 
-- On MINUS reduce production expr -> DECR expr 
-- On LT reduce production expr -> DECR expr 
-- On LPAREN reduce production expr -> DECR expr 
-- On LEQ reduce production expr -> DECR expr 
-- On IN reduce production expr -> DECR expr 
-- On GT reduce production expr -> DECR expr 
-- On GEQ reduce production expr -> DECR expr 
-- On EQ reduce production expr -> DECR expr 
-- On DIV reduce production expr -> DECR expr 
-- On COMMA reduce production expr -> DECR expr 
-- On ASSIGN reduce production expr -> DECR expr 
-- On AND reduce production expr -> DECR expr 
** Conflict on LPAREN

State 125:
expr -> expr . DOT IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ARROW IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ASSIGN expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . INCR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . DECR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> ECOMM expr . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . operateur expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On LPAREN shift to state 85
-- On INCR shift to state 106
-- On DOT shift to state 110
-- On DECR shift to state 113
-- On ARROW shift to state 116
-- On paren(separated_list(COMMA,expr)) shift to state 119
-- On operateur shift to state 120
-- On TIMES reduce production expr -> ECOMM expr 
-- On SEMICOLON reduce production expr -> ECOMM expr 
-- On RPAREN reduce production expr -> ECOMM expr 
-- On PLUS reduce production expr -> ECOMM expr 
-- On OR reduce production expr -> ECOMM expr 
-- On NEQ reduce production expr -> ECOMM expr 
-- On MOD reduce production expr -> ECOMM expr 
-- On MINUS reduce production expr -> ECOMM expr 
-- On LT reduce production expr -> ECOMM expr 
-- On LPAREN reduce production expr -> ECOMM expr 
-- On LEQ reduce production expr -> ECOMM expr 
-- On IN reduce production expr -> ECOMM expr 
-- On GT reduce production expr -> ECOMM expr 
-- On GEQ reduce production expr -> ECOMM expr 
-- On EQ reduce production expr -> ECOMM expr 
-- On DIV reduce production expr -> ECOMM expr 
-- On COMMA reduce production expr -> ECOMM expr 
-- On ASSIGN reduce production expr -> ECOMM expr 
-- On AND reduce production expr -> ECOMM expr 
** Conflict on LPAREN

State 126:
expr -> expr . DOT IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ARROW IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ASSIGN expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> INCR expr . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . INCR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . DECR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . operateur expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On LPAREN shift to state 85
-- On INCR shift to state 106
-- On DOT shift to state 110
-- On DECR shift to state 113
-- On ARROW shift to state 116
-- On paren(separated_list(COMMA,expr)) shift to state 119
-- On operateur shift to state 120
-- On TIMES reduce production expr -> INCR expr 
-- On SEMICOLON reduce production expr -> INCR expr 
-- On RPAREN reduce production expr -> INCR expr 
-- On PLUS reduce production expr -> INCR expr 
-- On OR reduce production expr -> INCR expr 
-- On NEQ reduce production expr -> INCR expr 
-- On MOD reduce production expr -> INCR expr 
-- On MINUS reduce production expr -> INCR expr 
-- On LT reduce production expr -> INCR expr 
-- On LPAREN reduce production expr -> INCR expr 
-- On LEQ reduce production expr -> INCR expr 
-- On IN reduce production expr -> INCR expr 
-- On GT reduce production expr -> INCR expr 
-- On GEQ reduce production expr -> INCR expr 
-- On EQ reduce production expr -> INCR expr 
-- On DIV reduce production expr -> INCR expr 
-- On COMMA reduce production expr -> INCR expr 
-- On ASSIGN reduce production expr -> INCR expr 
-- On AND reduce production expr -> INCR expr 
** Conflict on LPAREN

State 127:
loption(separated_nonempty_list(COMMA,expr)) -> separated_nonempty_list(COMMA,expr) . [ SEMICOLON RPAREN ]
-- On SEMICOLON reduce production loption(separated_nonempty_list(COMMA,expr)) -> separated_nonempty_list(COMMA,expr) 
-- On RPAREN reduce production loption(separated_nonempty_list(COMMA,expr)) -> separated_nonempty_list(COMMA,expr) 

State 128:
paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) . RPAREN [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On RPAREN shift to state 129

State 129:
paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On SEMICOLON reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On RPAREN reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On PLUS reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On OR reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On NEQ reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On MOD reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On MINUS reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On LT reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On LPAREN reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On LEQ reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On INCR reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On IN reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On GT reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On GEQ reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On EQ reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On DOT reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On DIV reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On DECR reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On COMMA reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On ASSIGN reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On ARROW reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 
-- On AND reduce production paren(separated_list(COMMA,expr)) -> LPAREN loption(separated_nonempty_list(COMMA,expr)) RPAREN 

State 130:
expr -> expr . DOT IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ARROW IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ASSIGN expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . INCR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . DECR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . operateur expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
separated_nonempty_list(COMMA,expr) -> expr . [ SEMICOLON RPAREN ]
separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ SEMICOLON RPAREN ]
-- On TIMES shift to state 98
-- On PLUS shift to state 99
-- On OR shift to state 100
-- On NEQ shift to state 101
-- On MOD shift to state 102
-- On MINUS shift to state 103
-- On LT shift to state 104
-- On LPAREN shift to state 85
-- On LEQ shift to state 105
-- On INCR shift to state 106
-- On GT shift to state 107
-- On GEQ shift to state 108
-- On EQ shift to state 109
-- On DOT shift to state 110
-- On DIV shift to state 112
-- On DECR shift to state 113
-- On COMMA shift to state 131
-- On ASSIGN shift to state 114
-- On ARROW shift to state 116
-- On AND shift to state 118
-- On paren(separated_list(COMMA,expr)) shift to state 119
-- On operateur shift to state 120
-- On SEMICOLON reduce production separated_nonempty_list(COMMA,expr) -> expr 
-- On RPAREN reduce production separated_nonempty_list(COMMA,expr) -> expr 

State 131:
separated_nonempty_list(COMMA,expr) -> expr COMMA . separated_nonempty_list(COMMA,expr) [ SEMICOLON RPAREN ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On separated_nonempty_list(COMMA,expr) shift to state 132
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On expr shift to state 130

State 132:
separated_nonempty_list(COMMA,expr) -> expr COMMA separated_nonempty_list(COMMA,expr) . [ SEMICOLON RPAREN ]
-- On SEMICOLON reduce production separated_nonempty_list(COMMA,expr) -> expr COMMA separated_nonempty_list(COMMA,expr) 
-- On RPAREN reduce production separated_nonempty_list(COMMA,expr) -> expr COMMA separated_nonempty_list(COMMA,expr) 

State 133:
expr -> NEW TIDENT paren(separated_list(COMMA,expr)) . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On TIMES reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On SEMICOLON reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On RPAREN reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On PLUS reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On OR reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On NEQ reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On MOD reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On MINUS reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On LT reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On LPAREN reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On LEQ reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On INCR reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On IN reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On GT reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On GEQ reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On EQ reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On DOT reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On DIV reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On DECR reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On COMMA reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On ASSIGN reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On ARROW reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 
-- On AND reduce production expr -> NEW TIDENT paren(separated_list(COMMA,expr)) 

State 134:
expr -> expr . DOT IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ARROW IDENT [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . ASSIGN expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . INCR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . DECR [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> NOT expr . [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
expr -> expr . operateur expr [ TIMES SEMICOLON RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR COMMA ASSIGN ARROW AND ]
-- On LPAREN shift to state 85
-- On INCR shift to state 106
-- On DOT shift to state 110
-- On DECR shift to state 113
-- On ARROW shift to state 116
-- On paren(separated_list(COMMA,expr)) shift to state 119
-- On operateur shift to state 120
-- On TIMES reduce production expr -> NOT expr 
-- On SEMICOLON reduce production expr -> NOT expr 
-- On RPAREN reduce production expr -> NOT expr 
-- On PLUS reduce production expr -> NOT expr 
-- On OR reduce production expr -> NOT expr 
-- On NEQ reduce production expr -> NOT expr 
-- On MOD reduce production expr -> NOT expr 
-- On MINUS reduce production expr -> NOT expr 
-- On LT reduce production expr -> NOT expr 
-- On LPAREN reduce production expr -> NOT expr 
-- On LEQ reduce production expr -> NOT expr 
-- On IN reduce production expr -> NOT expr 
-- On GT reduce production expr -> NOT expr 
-- On GEQ reduce production expr -> NOT expr 
-- On EQ reduce production expr -> NOT expr 
-- On DIV reduce production expr -> NOT expr 
-- On COMMA reduce production expr -> NOT expr 
-- On ASSIGN reduce production expr -> NOT expr 
-- On AND reduce production expr -> NOT expr 
** Conflict on LPAREN

State 135:
expr -> expr . DOT IDENT [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . ARROW IDENT [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . ASSIGN expr [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . paren(separated_list(COMMA,expr)) [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . INCR [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . DECR [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . operateur expr [ TIMES RPAREN PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
paren(expr) -> LPAREN expr . RPAREN [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RPAREN RETURN PLUS OR NULL NOT NEW NEQ MOD MINUS LT LPAREN LEQ LBRACE INT INCR IN IF IDENT GT GEQ FOR FALSE EQ ECOMM DOT DIV DECR COUT COMMA ASSIGN ARROW AND ]
-- On TIMES shift to state 98
-- On RPAREN shift to state 136
-- On PLUS shift to state 99
-- On OR shift to state 100
-- On NEQ shift to state 101
-- On MOD shift to state 102
-- On MINUS shift to state 103
-- On LT shift to state 104
-- On LPAREN shift to state 85
-- On LEQ shift to state 105
-- On INCR shift to state 106
-- On GT shift to state 107
-- On GEQ shift to state 108
-- On EQ shift to state 109
-- On DOT shift to state 110
-- On DIV shift to state 112
-- On DECR shift to state 113
-- On ASSIGN shift to state 114
-- On ARROW shift to state 116
-- On AND shift to state 118
-- On paren(separated_list(COMMA,expr)) shift to state 119
-- On operateur shift to state 120

State 136:
paren(expr) -> LPAREN expr RPAREN . [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RPAREN RETURN PLUS OR NULL NOT NEW NEQ MOD MINUS LT LPAREN LEQ LBRACE INT INCR IN IF IDENT GT GEQ FOR FALSE EQ ECOMM DOT DIV DECR COUT COMMA ASSIGN ARROW AND ]
-- On WHILE reduce production paren(expr) -> LPAREN expr RPAREN 
-- On VOID reduce production paren(expr) -> LPAREN expr RPAREN 
-- On TRUE reduce production paren(expr) -> LPAREN expr RPAREN 
-- On TINT reduce production paren(expr) -> LPAREN expr RPAREN 
-- On TIMES reduce production paren(expr) -> LPAREN expr RPAREN 
-- On TIDENT reduce production paren(expr) -> LPAREN expr RPAREN 
-- On THIS reduce production paren(expr) -> LPAREN expr RPAREN 
-- On SEMICOLON reduce production paren(expr) -> LPAREN expr RPAREN 
-- On RPAREN reduce production paren(expr) -> LPAREN expr RPAREN 
-- On RETURN reduce production paren(expr) -> LPAREN expr RPAREN 
-- On PLUS reduce production paren(expr) -> LPAREN expr RPAREN 
-- On OR reduce production paren(expr) -> LPAREN expr RPAREN 
-- On NULL reduce production paren(expr) -> LPAREN expr RPAREN 
-- On NOT reduce production paren(expr) -> LPAREN expr RPAREN 
-- On NEW reduce production paren(expr) -> LPAREN expr RPAREN 
-- On NEQ reduce production paren(expr) -> LPAREN expr RPAREN 
-- On MOD reduce production paren(expr) -> LPAREN expr RPAREN 
-- On MINUS reduce production paren(expr) -> LPAREN expr RPAREN 
-- On LT reduce production paren(expr) -> LPAREN expr RPAREN 
-- On LPAREN reduce production paren(expr) -> LPAREN expr RPAREN 
-- On LEQ reduce production paren(expr) -> LPAREN expr RPAREN 
-- On LBRACE reduce production paren(expr) -> LPAREN expr RPAREN 
-- On INT reduce production paren(expr) -> LPAREN expr RPAREN 
-- On INCR reduce production paren(expr) -> LPAREN expr RPAREN 
-- On IN reduce production paren(expr) -> LPAREN expr RPAREN 
-- On IF reduce production paren(expr) -> LPAREN expr RPAREN 
-- On IDENT reduce production paren(expr) -> LPAREN expr RPAREN 
-- On GT reduce production paren(expr) -> LPAREN expr RPAREN 
-- On GEQ reduce production paren(expr) -> LPAREN expr RPAREN 
-- On FOR reduce production paren(expr) -> LPAREN expr RPAREN 
-- On FALSE reduce production paren(expr) -> LPAREN expr RPAREN 
-- On EQ reduce production paren(expr) -> LPAREN expr RPAREN 
-- On ECOMM reduce production paren(expr) -> LPAREN expr RPAREN 
-- On DOT reduce production paren(expr) -> LPAREN expr RPAREN 
-- On DIV reduce production paren(expr) -> LPAREN expr RPAREN 
-- On DECR reduce production paren(expr) -> LPAREN expr RPAREN 
-- On COUT reduce production paren(expr) -> LPAREN expr RPAREN 
-- On COMMA reduce production paren(expr) -> LPAREN expr RPAREN 
-- On ASSIGN reduce production paren(expr) -> LPAREN expr RPAREN 
-- On ARROW reduce production paren(expr) -> LPAREN expr RPAREN 
-- On AND reduce production paren(expr) -> LPAREN expr RPAREN 

State 137:
instruction -> WHILE paren(expr) . instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On WHILE shift to state 76
-- On VOID shift to state 4
-- On TRUE shift to state 78
-- On TINT shift to state 5
-- On TIMES shift to state 10
-- On TIDENT shift to state 138
-- On THIS shift to state 79
-- On SEMICOLON shift to state 139
-- On RETURN shift to state 140
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On LBRACE shift to state 75
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IF shift to state 144
-- On IDENT shift to state 57
-- On FOR shift to state 146
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On COUT shift to state 154
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On type_rule shift to state 162
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On instruction shift to state 181
-- On expr shift to state 175
-- On bloc shift to state 177

State 138:
qident -> TIDENT . COLON COLON IDENT [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
type_rule -> TIDENT . [ TIMES IDENT ECOMM ]
-- On COLON shift to state 54
-- On TIMES reduce production type_rule -> TIDENT 
-- On IDENT reduce production type_rule -> TIDENT 
-- On ECOMM reduce production type_rule -> TIDENT 

State 139:
instruction -> SEMICOLON . [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On WHILE reduce production instruction -> SEMICOLON 
-- On VOID reduce production instruction -> SEMICOLON 
-- On TRUE reduce production instruction -> SEMICOLON 
-- On TINT reduce production instruction -> SEMICOLON 
-- On TIMES reduce production instruction -> SEMICOLON 
-- On TIDENT reduce production instruction -> SEMICOLON 
-- On THIS reduce production instruction -> SEMICOLON 
-- On SEMICOLON reduce production instruction -> SEMICOLON 
-- On RETURN reduce production instruction -> SEMICOLON 
-- On RBRACE reduce production instruction -> SEMICOLON 
-- On PLUS reduce production instruction -> SEMICOLON 
-- On NULL reduce production instruction -> SEMICOLON 
-- On NOT reduce production instruction -> SEMICOLON 
-- On NEW reduce production instruction -> SEMICOLON 
-- On MINUS reduce production instruction -> SEMICOLON 
-- On LPAREN reduce production instruction -> SEMICOLON 
-- On LBRACE reduce production instruction -> SEMICOLON 
-- On INT reduce production instruction -> SEMICOLON 
-- On INCR reduce production instruction -> SEMICOLON 
-- On IF reduce production instruction -> SEMICOLON 
-- On IDENT reduce production instruction -> SEMICOLON 
-- On FOR reduce production instruction -> SEMICOLON 
-- On FALSE reduce production instruction -> SEMICOLON 
-- On ELSE reduce production instruction -> SEMICOLON 
-- On ECOMM reduce production instruction -> SEMICOLON 
-- On DECR reduce production instruction -> SEMICOLON 
-- On COUT reduce production instruction -> SEMICOLON 

State 140:
instruction -> RETURN . option(expr) SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On option(expr) shift to state 141
-- On expr shift to state 143
-- On SEMICOLON reduce production option(expr) -> 

State 141:
instruction -> RETURN option(expr) . SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On SEMICOLON shift to state 142

State 142:
instruction -> RETURN option(expr) SEMICOLON . [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On WHILE reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On VOID reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On TRUE reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On TINT reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On TIMES reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On TIDENT reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On THIS reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On SEMICOLON reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On RETURN reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On RBRACE reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On PLUS reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On NULL reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On NOT reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On NEW reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On MINUS reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On LPAREN reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On LBRACE reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On INT reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On INCR reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On IF reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On IDENT reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On FOR reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On FALSE reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On ELSE reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On ECOMM reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On DECR reduce production instruction -> RETURN option(expr) SEMICOLON 
-- On COUT reduce production instruction -> RETURN option(expr) SEMICOLON 

State 143:
expr -> expr . DOT IDENT [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . ARROW IDENT [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . ASSIGN expr [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . INCR [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . DECR [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . operateur expr [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
option(expr) -> expr . [ SEMICOLON ]
-- On TIMES shift to state 98
-- On PLUS shift to state 99
-- On OR shift to state 100
-- On NEQ shift to state 101
-- On MOD shift to state 102
-- On MINUS shift to state 103
-- On LT shift to state 104
-- On LPAREN shift to state 85
-- On LEQ shift to state 105
-- On INCR shift to state 106
-- On GT shift to state 107
-- On GEQ shift to state 108
-- On EQ shift to state 109
-- On DOT shift to state 110
-- On DIV shift to state 112
-- On DECR shift to state 113
-- On ASSIGN shift to state 114
-- On ARROW shift to state 116
-- On AND shift to state 118
-- On paren(separated_list(COMMA,expr)) shift to state 119
-- On operateur shift to state 120
-- On SEMICOLON reduce production option(expr) -> expr 

State 144:
instruction -> IF . paren(expr) instruction ELSE instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
instruction -> IF . paren(expr) instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On LPAREN shift to state 77
-- On paren(expr) shift to state 145

State 145:
instruction -> IF paren(expr) . instruction ELSE instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
instruction -> IF paren(expr) . instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On WHILE shift to state 76
-- On VOID shift to state 4
-- On TRUE shift to state 78
-- On TINT shift to state 5
-- On TIMES shift to state 10
-- On TIDENT shift to state 138
-- On THIS shift to state 79
-- On SEMICOLON shift to state 139
-- On RETURN shift to state 140
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On LBRACE shift to state 75
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IF shift to state 144
-- On IDENT shift to state 57
-- On FOR shift to state 146
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On COUT shift to state 154
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On type_rule shift to state 162
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On instruction shift to state 178
-- On expr shift to state 175
-- On bloc shift to state 177

State 146:
instruction -> FOR . LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On LPAREN shift to state 147

State 147:
instruction -> FOR LPAREN . loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On separated_nonempty_list(COMMA,expr) shift to state 127
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On loption(separated_nonempty_list(COMMA,expr)) shift to state 148
-- On expr shift to state 130
-- On SEMICOLON reduce production loption(separated_nonempty_list(COMMA,expr)) -> 

State 148:
instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) . SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On SEMICOLON shift to state 149

State 149:
instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON . option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On option(expr) shift to state 150
-- On expr shift to state 143
-- On SEMICOLON reduce production option(expr) -> 

State 150:
instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) . SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On SEMICOLON shift to state 151

State 151:
instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON . loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On separated_nonempty_list(COMMA,expr) shift to state 127
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On loption(separated_nonempty_list(COMMA,expr)) shift to state 152
-- On expr shift to state 130
-- On RPAREN reduce production loption(separated_nonempty_list(COMMA,expr)) -> 

State 152:
instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) . RPAREN instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On RPAREN shift to state 153

State 153:
instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN . instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On WHILE shift to state 76
-- On VOID shift to state 4
-- On TRUE shift to state 78
-- On TINT shift to state 5
-- On TIMES shift to state 10
-- On TIDENT shift to state 138
-- On THIS shift to state 79
-- On SEMICOLON shift to state 139
-- On RETURN shift to state 140
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On LBRACE shift to state 75
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IF shift to state 144
-- On IDENT shift to state 57
-- On FOR shift to state 146
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On COUT shift to state 154
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On type_rule shift to state 162
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On instruction shift to state 174
-- On expr shift to state 175
-- On bloc shift to state 177

State 154:
instruction -> COUT . nonempty_list(preceded(IN,expr_str)) SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On IN shift to state 155
-- On nonempty_list(preceded(IN,expr_str)) shift to state 160

State 155:
nonempty_list(preceded(IN,expr_str)) -> IN . expr_str [ SEMICOLON ]
nonempty_list(preceded(IN,expr_str)) -> IN . expr_str nonempty_list(preceded(IN,expr_str)) [ SEMICOLON ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On STRING shift to state 156
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On expr_str shift to state 157
-- On expr shift to state 159

State 156:
expr_str -> STRING . [ SEMICOLON IN ]
-- On SEMICOLON reduce production expr_str -> STRING 
-- On IN reduce production expr_str -> STRING 

State 157:
nonempty_list(preceded(IN,expr_str)) -> IN expr_str . [ SEMICOLON ]
nonempty_list(preceded(IN,expr_str)) -> IN expr_str . nonempty_list(preceded(IN,expr_str)) [ SEMICOLON ]
-- On IN shift to state 155
-- On nonempty_list(preceded(IN,expr_str)) shift to state 158
-- On SEMICOLON reduce production nonempty_list(preceded(IN,expr_str)) -> IN expr_str 

State 158:
nonempty_list(preceded(IN,expr_str)) -> IN expr_str nonempty_list(preceded(IN,expr_str)) . [ SEMICOLON ]
-- On SEMICOLON reduce production nonempty_list(preceded(IN,expr_str)) -> IN expr_str nonempty_list(preceded(IN,expr_str)) 

State 159:
expr -> expr . DOT IDENT [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . ARROW IDENT [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . ASSIGN expr [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . INCR [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . DECR [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . operateur expr [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR IN GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr_str -> expr . [ SEMICOLON IN ]
-- On TIMES shift to state 98
-- On PLUS shift to state 99
-- On OR shift to state 100
-- On NEQ shift to state 101
-- On MOD shift to state 102
-- On MINUS shift to state 103
-- On LT shift to state 104
-- On LPAREN shift to state 85
-- On LEQ shift to state 105
-- On INCR shift to state 106
-- On GT shift to state 107
-- On GEQ shift to state 108
-- On EQ shift to state 109
-- On DOT shift to state 110
-- On DIV shift to state 112
-- On DECR shift to state 113
-- On ASSIGN shift to state 114
-- On ARROW shift to state 116
-- On AND shift to state 118
-- On paren(separated_list(COMMA,expr)) shift to state 119
-- On operateur shift to state 120
-- On SEMICOLON reduce production expr_str -> expr 
-- On IN reduce production expr_str -> expr 

State 160:
instruction -> COUT nonempty_list(preceded(IN,expr_str)) . SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On SEMICOLON shift to state 161

State 161:
instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON . [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On WHILE reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On VOID reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On TRUE reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On TINT reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On TIMES reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On TIDENT reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On THIS reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On SEMICOLON reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On RETURN reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On RBRACE reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On PLUS reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On NULL reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On NOT reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On NEW reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On MINUS reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On LPAREN reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On LBRACE reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On INT reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On INCR reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On IF reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On IDENT reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On FOR reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On FALSE reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On ELSE reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On ECOMM reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On DECR reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 
-- On COUT reduce production instruction -> COUT nonempty_list(preceded(IN,expr_str)) SEMICOLON 

State 162:
instruction -> type_rule . var SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
instruction -> type_rule . var ASSIGN expr SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
instruction -> type_rule . var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On TIMES shift to state 10
-- On IDENT shift to state 11
-- On ECOMM shift to state 12
-- On var shift to state 163
-- On unary_times shift to state 14

State 163:
instruction -> type_rule var . SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
instruction -> type_rule var . ASSIGN expr SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
instruction -> type_rule var . ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On SEMICOLON shift to state 164
-- On ASSIGN shift to state 165

State 164:
instruction -> type_rule var SEMICOLON . [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On WHILE reduce production instruction -> type_rule var SEMICOLON 
-- On VOID reduce production instruction -> type_rule var SEMICOLON 
-- On TRUE reduce production instruction -> type_rule var SEMICOLON 
-- On TINT reduce production instruction -> type_rule var SEMICOLON 
-- On TIMES reduce production instruction -> type_rule var SEMICOLON 
-- On TIDENT reduce production instruction -> type_rule var SEMICOLON 
-- On THIS reduce production instruction -> type_rule var SEMICOLON 
-- On SEMICOLON reduce production instruction -> type_rule var SEMICOLON 
-- On RETURN reduce production instruction -> type_rule var SEMICOLON 
-- On RBRACE reduce production instruction -> type_rule var SEMICOLON 
-- On PLUS reduce production instruction -> type_rule var SEMICOLON 
-- On NULL reduce production instruction -> type_rule var SEMICOLON 
-- On NOT reduce production instruction -> type_rule var SEMICOLON 
-- On NEW reduce production instruction -> type_rule var SEMICOLON 
-- On MINUS reduce production instruction -> type_rule var SEMICOLON 
-- On LPAREN reduce production instruction -> type_rule var SEMICOLON 
-- On LBRACE reduce production instruction -> type_rule var SEMICOLON 
-- On INT reduce production instruction -> type_rule var SEMICOLON 
-- On INCR reduce production instruction -> type_rule var SEMICOLON 
-- On IF reduce production instruction -> type_rule var SEMICOLON 
-- On IDENT reduce production instruction -> type_rule var SEMICOLON 
-- On FOR reduce production instruction -> type_rule var SEMICOLON 
-- On FALSE reduce production instruction -> type_rule var SEMICOLON 
-- On ELSE reduce production instruction -> type_rule var SEMICOLON 
-- On ECOMM reduce production instruction -> type_rule var SEMICOLON 
-- On DECR reduce production instruction -> type_rule var SEMICOLON 
-- On COUT reduce production instruction -> type_rule var SEMICOLON 

State 165:
instruction -> type_rule var ASSIGN . expr SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
instruction -> type_rule var ASSIGN . TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 166
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On expr shift to state 172

State 166:
instruction -> type_rule var ASSIGN TIDENT . paren(separated_nonempty_list(COMMA,expr)) SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
qident -> TIDENT . COLON COLON IDENT [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
-- On LPAREN shift to state 167
-- On COLON shift to state 54
-- On paren(separated_nonempty_list(COMMA,expr)) shift to state 170

State 167:
paren(separated_nonempty_list(COMMA,expr)) -> LPAREN . separated_nonempty_list(COMMA,expr) RPAREN [ SEMICOLON ]
-- On TRUE shift to state 78
-- On TIMES shift to state 10
-- On TIDENT shift to state 53
-- On THIS shift to state 79
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IDENT shift to state 57
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On separated_nonempty_list(COMMA,expr) shift to state 168
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On expr shift to state 130

State 168:
paren(separated_nonempty_list(COMMA,expr)) -> LPAREN separated_nonempty_list(COMMA,expr) . RPAREN [ SEMICOLON ]
-- On RPAREN shift to state 169

State 169:
paren(separated_nonempty_list(COMMA,expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN . [ SEMICOLON ]
-- On SEMICOLON reduce production paren(separated_nonempty_list(COMMA,expr)) -> LPAREN separated_nonempty_list(COMMA,expr) RPAREN 

State 170:
instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) . SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On SEMICOLON shift to state 171

State 171:
instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON . [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On WHILE reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On VOID reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On TRUE reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On TINT reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On TIMES reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On TIDENT reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On THIS reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On SEMICOLON reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On RETURN reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On RBRACE reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On PLUS reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On NULL reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On NOT reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On NEW reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On MINUS reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On LPAREN reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On LBRACE reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On INT reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On INCR reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On IF reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On IDENT reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On FOR reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On FALSE reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On ELSE reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On ECOMM reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On DECR reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 
-- On COUT reduce production instruction -> type_rule var ASSIGN TIDENT paren(separated_nonempty_list(COMMA,expr)) SEMICOLON 

State 172:
expr -> expr . DOT IDENT [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . ARROW IDENT [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . ASSIGN expr [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . INCR [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . DECR [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . operateur expr [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
instruction -> type_rule var ASSIGN expr . SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On TIMES shift to state 98
-- On SEMICOLON shift to state 173
-- On PLUS shift to state 99
-- On OR shift to state 100
-- On NEQ shift to state 101
-- On MOD shift to state 102
-- On MINUS shift to state 103
-- On LT shift to state 104
-- On LPAREN shift to state 85
-- On LEQ shift to state 105
-- On INCR shift to state 106
-- On GT shift to state 107
-- On GEQ shift to state 108
-- On EQ shift to state 109
-- On DOT shift to state 110
-- On DIV shift to state 112
-- On DECR shift to state 113
-- On ASSIGN shift to state 114
-- On ARROW shift to state 116
-- On AND shift to state 118
-- On paren(separated_list(COMMA,expr)) shift to state 119
-- On operateur shift to state 120

State 173:
instruction -> type_rule var ASSIGN expr SEMICOLON . [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On WHILE reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On VOID reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On TRUE reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On TINT reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On TIMES reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On TIDENT reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On THIS reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On SEMICOLON reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On RETURN reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On RBRACE reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On PLUS reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On NULL reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On NOT reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On NEW reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On MINUS reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On LPAREN reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On LBRACE reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On INT reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On INCR reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On IF reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On IDENT reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On FOR reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On FALSE reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On ELSE reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On ECOMM reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On DECR reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 
-- On COUT reduce production instruction -> type_rule var ASSIGN expr SEMICOLON 

State 174:
instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction . [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On WHILE reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On VOID reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On TRUE reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On TINT reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On TIMES reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On TIDENT reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On THIS reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On SEMICOLON reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On RETURN reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On RBRACE reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On PLUS reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On NULL reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On NOT reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On NEW reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On MINUS reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On LPAREN reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On LBRACE reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On INT reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On INCR reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On IF reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On IDENT reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On FOR reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On FALSE reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On ELSE reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On ECOMM reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On DECR reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 
-- On COUT reduce production instruction -> FOR LPAREN loption(separated_nonempty_list(COMMA,expr)) SEMICOLON option(expr) SEMICOLON loption(separated_nonempty_list(COMMA,expr)) RPAREN instruction 

State 175:
expr -> expr . DOT IDENT [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . ARROW IDENT [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . ASSIGN expr [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . paren(separated_list(COMMA,expr)) [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . INCR [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . DECR [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
expr -> expr . operateur expr [ TIMES SEMICOLON PLUS OR NEQ MOD MINUS LT LPAREN LEQ INCR GT GEQ EQ DOT DIV DECR ASSIGN ARROW AND ]
instruction -> expr . SEMICOLON [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On TIMES shift to state 98
-- On SEMICOLON shift to state 176
-- On PLUS shift to state 99
-- On OR shift to state 100
-- On NEQ shift to state 101
-- On MOD shift to state 102
-- On MINUS shift to state 103
-- On LT shift to state 104
-- On LPAREN shift to state 85
-- On LEQ shift to state 105
-- On INCR shift to state 106
-- On GT shift to state 107
-- On GEQ shift to state 108
-- On EQ shift to state 109
-- On DOT shift to state 110
-- On DIV shift to state 112
-- On DECR shift to state 113
-- On ASSIGN shift to state 114
-- On ARROW shift to state 116
-- On AND shift to state 118
-- On paren(separated_list(COMMA,expr)) shift to state 119
-- On operateur shift to state 120

State 176:
instruction -> expr SEMICOLON . [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On WHILE reduce production instruction -> expr SEMICOLON 
-- On VOID reduce production instruction -> expr SEMICOLON 
-- On TRUE reduce production instruction -> expr SEMICOLON 
-- On TINT reduce production instruction -> expr SEMICOLON 
-- On TIMES reduce production instruction -> expr SEMICOLON 
-- On TIDENT reduce production instruction -> expr SEMICOLON 
-- On THIS reduce production instruction -> expr SEMICOLON 
-- On SEMICOLON reduce production instruction -> expr SEMICOLON 
-- On RETURN reduce production instruction -> expr SEMICOLON 
-- On RBRACE reduce production instruction -> expr SEMICOLON 
-- On PLUS reduce production instruction -> expr SEMICOLON 
-- On NULL reduce production instruction -> expr SEMICOLON 
-- On NOT reduce production instruction -> expr SEMICOLON 
-- On NEW reduce production instruction -> expr SEMICOLON 
-- On MINUS reduce production instruction -> expr SEMICOLON 
-- On LPAREN reduce production instruction -> expr SEMICOLON 
-- On LBRACE reduce production instruction -> expr SEMICOLON 
-- On INT reduce production instruction -> expr SEMICOLON 
-- On INCR reduce production instruction -> expr SEMICOLON 
-- On IF reduce production instruction -> expr SEMICOLON 
-- On IDENT reduce production instruction -> expr SEMICOLON 
-- On FOR reduce production instruction -> expr SEMICOLON 
-- On FALSE reduce production instruction -> expr SEMICOLON 
-- On ELSE reduce production instruction -> expr SEMICOLON 
-- On ECOMM reduce production instruction -> expr SEMICOLON 
-- On DECR reduce production instruction -> expr SEMICOLON 
-- On COUT reduce production instruction -> expr SEMICOLON 

State 177:
instruction -> bloc . [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On WHILE reduce production instruction -> bloc 
-- On VOID reduce production instruction -> bloc 
-- On TRUE reduce production instruction -> bloc 
-- On TINT reduce production instruction -> bloc 
-- On TIMES reduce production instruction -> bloc 
-- On TIDENT reduce production instruction -> bloc 
-- On THIS reduce production instruction -> bloc 
-- On SEMICOLON reduce production instruction -> bloc 
-- On RETURN reduce production instruction -> bloc 
-- On RBRACE reduce production instruction -> bloc 
-- On PLUS reduce production instruction -> bloc 
-- On NULL reduce production instruction -> bloc 
-- On NOT reduce production instruction -> bloc 
-- On NEW reduce production instruction -> bloc 
-- On MINUS reduce production instruction -> bloc 
-- On LPAREN reduce production instruction -> bloc 
-- On LBRACE reduce production instruction -> bloc 
-- On INT reduce production instruction -> bloc 
-- On INCR reduce production instruction -> bloc 
-- On IF reduce production instruction -> bloc 
-- On IDENT reduce production instruction -> bloc 
-- On FOR reduce production instruction -> bloc 
-- On FALSE reduce production instruction -> bloc 
-- On ELSE reduce production instruction -> bloc 
-- On ECOMM reduce production instruction -> bloc 
-- On DECR reduce production instruction -> bloc 
-- On COUT reduce production instruction -> bloc 

State 178:
instruction -> IF paren(expr) instruction . ELSE instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
instruction -> IF paren(expr) instruction . [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On ELSE shift to state 179
-- On WHILE reduce production instruction -> IF paren(expr) instruction 
-- On VOID reduce production instruction -> IF paren(expr) instruction 
-- On TRUE reduce production instruction -> IF paren(expr) instruction 
-- On TINT reduce production instruction -> IF paren(expr) instruction 
-- On TIMES reduce production instruction -> IF paren(expr) instruction 
-- On TIDENT reduce production instruction -> IF paren(expr) instruction 
-- On THIS reduce production instruction -> IF paren(expr) instruction 
-- On SEMICOLON reduce production instruction -> IF paren(expr) instruction 
-- On RETURN reduce production instruction -> IF paren(expr) instruction 
-- On RBRACE reduce production instruction -> IF paren(expr) instruction 
-- On PLUS reduce production instruction -> IF paren(expr) instruction 
-- On NULL reduce production instruction -> IF paren(expr) instruction 
-- On NOT reduce production instruction -> IF paren(expr) instruction 
-- On NEW reduce production instruction -> IF paren(expr) instruction 
-- On MINUS reduce production instruction -> IF paren(expr) instruction 
-- On LPAREN reduce production instruction -> IF paren(expr) instruction 
-- On LBRACE reduce production instruction -> IF paren(expr) instruction 
-- On INT reduce production instruction -> IF paren(expr) instruction 
-- On INCR reduce production instruction -> IF paren(expr) instruction 
-- On IF reduce production instruction -> IF paren(expr) instruction 
-- On IDENT reduce production instruction -> IF paren(expr) instruction 
-- On FOR reduce production instruction -> IF paren(expr) instruction 
-- On FALSE reduce production instruction -> IF paren(expr) instruction 
-- On ELSE reduce production instruction -> IF paren(expr) instruction 
-- On ECOMM reduce production instruction -> IF paren(expr) instruction 
-- On DECR reduce production instruction -> IF paren(expr) instruction 
-- On COUT reduce production instruction -> IF paren(expr) instruction 
** Conflict on ELSE

State 179:
instruction -> IF paren(expr) instruction ELSE . instruction [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On WHILE shift to state 76
-- On VOID shift to state 4
-- On TRUE shift to state 78
-- On TINT shift to state 5
-- On TIMES shift to state 10
-- On TIDENT shift to state 138
-- On THIS shift to state 79
-- On SEMICOLON shift to state 139
-- On RETURN shift to state 140
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On LBRACE shift to state 75
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IF shift to state 144
-- On IDENT shift to state 57
-- On FOR shift to state 146
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On COUT shift to state 154
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On type_rule shift to state 162
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On instruction shift to state 180
-- On expr shift to state 175
-- On bloc shift to state 177

State 180:
instruction -> IF paren(expr) instruction ELSE instruction . [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On WHILE reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On VOID reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On TRUE reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On TINT reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On TIMES reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On TIDENT reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On THIS reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On SEMICOLON reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On RETURN reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On RBRACE reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On PLUS reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On NULL reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On NOT reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On NEW reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On MINUS reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On LPAREN reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On LBRACE reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On INT reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On INCR reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On IF reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On IDENT reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On FOR reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On FALSE reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On ELSE reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On ECOMM reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On DECR reduce production instruction -> IF paren(expr) instruction ELSE instruction 
-- On COUT reduce production instruction -> IF paren(expr) instruction ELSE instruction 

State 181:
instruction -> WHILE paren(expr) instruction . [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE ELSE ECOMM DECR COUT ]
-- On WHILE reduce production instruction -> WHILE paren(expr) instruction 
-- On VOID reduce production instruction -> WHILE paren(expr) instruction 
-- On TRUE reduce production instruction -> WHILE paren(expr) instruction 
-- On TINT reduce production instruction -> WHILE paren(expr) instruction 
-- On TIMES reduce production instruction -> WHILE paren(expr) instruction 
-- On TIDENT reduce production instruction -> WHILE paren(expr) instruction 
-- On THIS reduce production instruction -> WHILE paren(expr) instruction 
-- On SEMICOLON reduce production instruction -> WHILE paren(expr) instruction 
-- On RETURN reduce production instruction -> WHILE paren(expr) instruction 
-- On RBRACE reduce production instruction -> WHILE paren(expr) instruction 
-- On PLUS reduce production instruction -> WHILE paren(expr) instruction 
-- On NULL reduce production instruction -> WHILE paren(expr) instruction 
-- On NOT reduce production instruction -> WHILE paren(expr) instruction 
-- On NEW reduce production instruction -> WHILE paren(expr) instruction 
-- On MINUS reduce production instruction -> WHILE paren(expr) instruction 
-- On LPAREN reduce production instruction -> WHILE paren(expr) instruction 
-- On LBRACE reduce production instruction -> WHILE paren(expr) instruction 
-- On INT reduce production instruction -> WHILE paren(expr) instruction 
-- On INCR reduce production instruction -> WHILE paren(expr) instruction 
-- On IF reduce production instruction -> WHILE paren(expr) instruction 
-- On IDENT reduce production instruction -> WHILE paren(expr) instruction 
-- On FOR reduce production instruction -> WHILE paren(expr) instruction 
-- On FALSE reduce production instruction -> WHILE paren(expr) instruction 
-- On ELSE reduce production instruction -> WHILE paren(expr) instruction 
-- On ECOMM reduce production instruction -> WHILE paren(expr) instruction 
-- On DECR reduce production instruction -> WHILE paren(expr) instruction 
-- On COUT reduce production instruction -> WHILE paren(expr) instruction 

State 182:
bloc -> LBRACE list(instruction) . RBRACE [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE EOF ELSE ECOMM DECR COUT CLASS ]
-- On RBRACE shift to state 183

State 183:
bloc -> LBRACE list(instruction) RBRACE . [ WHILE VOID TRUE TINT TIMES TIDENT THIS SEMICOLON RETURN RBRACE PLUS NULL NOT NEW MINUS LPAREN LBRACE INT INCR IF IDENT FOR FALSE EOF ELSE ECOMM DECR COUT CLASS ]
-- On WHILE reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On VOID reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On TRUE reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On TINT reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On TIMES reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On TIDENT reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On THIS reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On SEMICOLON reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On RETURN reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On RBRACE reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On PLUS reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On NULL reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On NOT reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On NEW reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On MINUS reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On LPAREN reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On LBRACE reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On INT reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On INCR reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On IF reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On IDENT reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On FOR reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On FALSE reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On EOF reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On ELSE reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On ECOMM reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On DECR reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On COUT reduce production bloc -> LBRACE list(instruction) RBRACE 
-- On CLASS reduce production bloc -> LBRACE list(instruction) RBRACE 

State 184:
list(instruction) -> instruction . list(instruction) [ RBRACE ]
-- On WHILE shift to state 76
-- On VOID shift to state 4
-- On TRUE shift to state 78
-- On TINT shift to state 5
-- On TIMES shift to state 10
-- On TIDENT shift to state 138
-- On THIS shift to state 79
-- On SEMICOLON shift to state 139
-- On RETURN shift to state 140
-- On PLUS shift to state 80
-- On NULL shift to state 81
-- On NOT shift to state 82
-- On NEW shift to state 83
-- On MINUS shift to state 86
-- On LPAREN shift to state 77
-- On LBRACE shift to state 75
-- On INT shift to state 87
-- On INCR shift to state 88
-- On IF shift to state 144
-- On IDENT shift to state 57
-- On FOR shift to state 146
-- On FALSE shift to state 89
-- On ECOMM shift to state 90
-- On DECR shift to state 91
-- On COUT shift to state 154
-- On unary_times shift to state 92
-- On unary_plus shift to state 93
-- On unary_minus shift to state 94
-- On type_rule shift to state 162
-- On qident shift to state 95
-- On paren(expr) shift to state 96
-- On list(instruction) shift to state 185
-- On instruction shift to state 184
-- On expr shift to state 175
-- On bloc shift to state 177
-- On RBRACE reduce production list(instruction) -> 

State 185:
list(instruction) -> instruction list(instruction) . [ RBRACE ]
-- On RBRACE reduce production list(instruction) -> instruction list(instruction) 

State 186:
decl -> proto bloc . [ VOID TINT TIDENT EOF CLASS ]
-- On VOID reduce production decl -> proto bloc 
-- On TINT reduce production decl -> proto bloc 
-- On TIDENT reduce production decl -> proto bloc 
-- On EOF reduce production decl -> proto bloc 
-- On CLASS reduce production decl -> proto bloc 

State 187:
fichier -> boption(INCLUDE) list(decl) . EOF [ # ]
-- On EOF shift to state 188

State 188:
fichier -> boption(INCLUDE) list(decl) EOF . [ # ]
-- On # reduce production fichier -> boption(INCLUDE) list(decl) EOF 

State 189:
decl -> decl_vars . [ VOID TINT TIDENT EOF CLASS ]
-- On VOID reduce production decl -> decl_vars 
-- On TINT reduce production decl -> decl_vars 
-- On TIDENT reduce production decl -> decl_vars 
-- On EOF reduce production decl -> decl_vars 
-- On CLASS reduce production decl -> decl_vars 

State 190:
decl -> decl_class . [ VOID TINT TIDENT EOF CLASS ]
-- On VOID reduce production decl -> decl_class 
-- On TINT reduce production decl -> decl_class 
-- On TIDENT reduce production decl -> decl_class 
-- On EOF reduce production decl -> decl_class 
-- On CLASS reduce production decl -> decl_class 

State 191:
list(decl) -> decl . list(decl) [ EOF ]
-- On VOID shift to state 4
-- On TINT shift to state 5
-- On TIDENT shift to state 6
-- On CLASS shift to state 28
-- On type_rule shift to state 70
-- On proto shift to state 74
-- On list(decl) shift to state 192
-- On decl_vars shift to state 189
-- On decl_class shift to state 190
-- On decl shift to state 191
-- On EOF reduce production list(decl) -> 

State 192:
list(decl) -> decl list(decl) . [ EOF ]
-- On EOF reduce production list(decl) -> decl list(decl) 

